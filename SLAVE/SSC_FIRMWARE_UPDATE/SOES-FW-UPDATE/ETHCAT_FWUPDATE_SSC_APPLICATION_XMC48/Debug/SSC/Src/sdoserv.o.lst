   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "sdoserv.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .comm u8PendingSdo,1,1
  20              	 .comm bStoreCompleteAccess,1,1
  21              	 .comm u8StoreSubindex,1,1
  22              	 .comm u16StoreIndex,2,2
  23              	 .comm u32StoreDataSize,4,4
  24              	 .comm pStoreData,4,4
  25              	 .comm pSdoPendFunc,4,4
  26              	 .comm aSdoInfoHeader,16,4
  27              	 .comm pSdoSegData,4,4
  28              	 .comm nSdoInfoFragmentsLeft,2,2
  29              	 .global cAbortCode
  30              	 .section .rodata.cAbortCode,"a",%progbits
  31              	 .align 2
  34              	cAbortCode:
  35 0000 00000000 	 .word 0
  36 0004 00000305 	 .word 84082688
  37 0008 00000405 	 .word 84148224
  38 000c 01000405 	 .word 84148225
  39 0010 05000405 	 .word 84148229
  40 0014 00000106 	 .word 100728832
  41 0018 01000106 	 .word 100728833
  42 001c 02000106 	 .word 100728834
  43 0020 00000206 	 .word 100794368
  44 0024 41000406 	 .word 100925505
  45 0028 42000406 	 .word 100925506
  46 002c 43000406 	 .word 100925507
  47 0030 47000406 	 .word 100925511
  48 0034 00000606 	 .word 101056512
  49 0038 10000706 	 .word 101122064
  50 003c 12000706 	 .word 101122066
  51 0040 13000706 	 .word 101122067
  52 0044 11000906 	 .word 101253137
  53 0048 30000906 	 .word 101253168
  54 004c 31000906 	 .word 101253169
  55 0050 32000906 	 .word 101253170
  56 0054 33000906 	 .word 101253171
  57 0058 36000906 	 .word 101253174
  58 005c 00000008 	 .word 134217728
  59 0060 20000008 	 .word 134217760
  60 0064 21000008 	 .word 134217761
  61 0068 22000008 	 .word 134217762
  62 006c 23000008 	 .word 134217763
  63 0070 03000106 	 .word 100728835
  64 0074 04000106 	 .word 100728836
  65              	 .comm nSdoInfoIndex,2,2
  66              	 .comm pSdoInfoObjEntry,4,4
  67              	 .comm pSdoResStored,4,4
  68              	 .global bSdoInWork
  69              	 .section .bss.bSdoInWork,"aw",%nobits
  72              	bSdoInWork:
  73 0000 00       	 .space 1
  74              	 .comm nSdoSegService,1,1
  75              	 .comm bSdoSegFollows,1,1
  76              	 .comm bSdoSegAccess,1,1
  77              	 .comm nSdoSegIndex,2,2
  78              	 .comm nSdoSegSubindex,1,1
  79              	 .comm nSdoSegBytesToHandle,4,4
  80              	 .comm bSdoSegLastToggle,1,1
  81              	 .comm nSdoSegCompleteSize,4,4
  82              	 .comm pSdoSegObjEntry,4,4
  83              	 .section .text.SdoDownloadSegmentInd,"ax",%progbits
  84              	 .align 2
  85              	 .thumb
  86              	 .thumb_func
  88              	SdoDownloadSegmentInd:
  89              	.LFB172:
  90              	 .file 1 "../SSC/Src/sdoserv.c"
   1:../SSC/Src/sdoserv.c **** /**
   2:../SSC/Src/sdoserv.c **** \addtogroup CoE CAN Application Profile over EtherCAT
   3:../SSC/Src/sdoserv.c **** @{
   4:../SSC/Src/sdoserv.c **** */
   5:../SSC/Src/sdoserv.c **** 
   6:../SSC/Src/sdoserv.c **** /**
   7:../SSC/Src/sdoserv.c **** \file    sdoserv.c
   8:../SSC/Src/sdoserv.c **** \author EthercatSSC@beckhoff.com
   9:../SSC/Src/sdoserv.c **** \brief Implementation
  10:../SSC/Src/sdoserv.c **** The SDO server handles all sdo and sdo information services
  11:../SSC/Src/sdoserv.c **** 
  12:../SSC/Src/sdoserv.c **** \version 5.11
  13:../SSC/Src/sdoserv.c **** 
  14:../SSC/Src/sdoserv.c **** <br>Changes to version V5.10:<br>
  15:../SSC/Src/sdoserv.c **** V5.11 ECAT10: change PROTO handling to prevent compiler errors<br>
  16:../SSC/Src/sdoserv.c **** V5.11 ECAT7: add missing big endian swapping<br>
  17:../SSC/Src/sdoserv.c **** V5.11 SDO10: add new SDO abort code 0x6010004 (complete access not supported)<br>
  18:../SSC/Src/sdoserv.c **** V5.11 SDO4: "if insufficient memory is available on complete download access return ""unsupported a
  19:../SSC/Src/sdoserv.c **** <br>Changes to version V5.01:<br>
  20:../SSC/Src/sdoserv.c **** V5.10 ESC5: Add missing swapping<br>
  21:../SSC/Src/sdoserv.c **** V5.10 MBX1: Remove multiple swapping of length filed in mailbox header<br>
  22:../SSC/Src/sdoserv.c **** V5.10 SDO3: Add new SDO Abort Code (0x06090033)<br>
  23:../SSC/Src/sdoserv.c **** V5.10 SDO4: Block SDO Info services for indices less 0x1000<br>
  24:../SSC/Src/sdoserv.c **** V5.10 SDO7: Correct mailbox length calculation on segmented or normal SDO upload response<br>
  25:../SSC/Src/sdoserv.c **** V5.10 SDO8: Fix invalid fragment calculation on SdoInfo list response<br>
  26:../SSC/Src/sdoserv.c **** V5.10 TEST5: test 0x2020.1 change limit from 10 to 16 Byte <br>
  27:../SSC/Src/sdoserv.c ****              Add test object 0x3009/0x300A (huge array and record objects)<br>
  28:../SSC/Src/sdoserv.c **** <br>Changes to version V5.0:<br>
  29:../SSC/Src/sdoserv.c **** V5.01 MBX1: Allocate always complete 16Bit memory areas<br>
  30:../SSC/Src/sdoserv.c **** V5.01 SDO2: Prevent invalid memory access in case of 8Bit mailbox memory handling<br>
  31:../SSC/Src/sdoserv.c **** V5.01 SDO3: Update mailbox data length calculation<br>
  32:../SSC/Src/sdoserv.c **** V5.01 SDO4: Update length calculation in case of an segmented SDO list response<br>
  33:../SSC/Src/sdoserv.c **** V5.01 SDO6: Update SDO response interface handling. (used if the object access function returns "AB
  34:../SSC/Src/sdoserv.c **** V5.01 TEST2: Change Test 0x2020.1 (force Segmented transfer) to 16Byte<br>
  35:../SSC/Src/sdoserv.c **** <br>Changes to version V4.40:<br>
  36:../SSC/Src/sdoserv.c **** V5.0 TEST1: Add test application. see Application Note ET9300 for more details.<br>
  37:../SSC/Src/sdoserv.c **** V5.0 MBX3: Calculate MBX datagram length independent of SM size.<br>
  38:../SSC/Src/sdoserv.c **** V5.0 SDO2: SDO toggle bit don not do be cleared for segmented communication.<br>
  39:../SSC/Src/sdoserv.c **** V5.0 SDO3: Set SDO OpCode in list response.<br>
  40:../SSC/Src/sdoserv.c **** V5.0 SDO4: Update abort code for "BIG_ENDIAN_16BIT" configuration.<br>
  41:../SSC/Src/sdoserv.c **** V5.0 SDO5: Object code was calculated wrong for SDO Info service.<br>
  42:../SSC/Src/sdoserv.c **** V5.0 SDO6: Handle SDO segmented transfer if only 16Bit MBX memory access is allowed. <br>
  43:../SSC/Src/sdoserv.c **** <br>Changes to version V4.20:<br>
  44:../SSC/Src/sdoserv.c **** V4.40 SDO1: change size calculation for SDO services<br>
  45:../SSC/Src/sdoserv.c **** V4.40 MBX1: Prevent accessing odd address<br>
  46:../SSC/Src/sdoserv.c **** V4.40 COE1: Abort code is set in OBJ_GetObjectList()<br>
  47:../SSC/Src/sdoserv.c **** <br>Changes to version V4.11:<br>
  48:../SSC/Src/sdoserv.c **** V4.20 PIC24: Add EL9800_4 (PIC24) required source code<br>
  49:../SSC/Src/sdoserv.c **** V4.20 SDO 2: SDO mask value bug<br>
  50:../SSC/Src/sdoserv.c **** V4.20 SDO 1: check zero size object length<br>
  51:../SSC/Src/sdoserv.c **** <br>Changes to version V4.10:<br>
  52:../SSC/Src/sdoserv.c **** V4.11 SDO 1: fixed calculation of frame fragments during a object dictionary array list request<br>
  53:../SSC/Src/sdoserv.c **** V4.11 SDO 2-3: fixed size of entry description<br>
  54:../SSC/Src/sdoserv.c **** V4.11 SDO 4-7: add STRUCT_PACKED defines<br>
  55:../SSC/Src/sdoserv.c **** <br>Changes to version V4.08:\a<br>
  56:../SSC/Src/sdoserv.c **** V4.10 SDO 1: fixed zero size SDO comparison<br>
  57:../SSC/Src/sdoserv.c **** V4.10 SDO 2: set SdoService_CommandOffset to 0<br>
  58:../SSC/Src/sdoserv.c **** V4.10 SDO 3: fixed zero size SDO comparison<br>
  59:../SSC/Src/sdoserv.c **** V4.10 SDO 4: fixed struct_packed definition<br>
  60:../SSC/Src/sdoserv.c **** <br>Changes to version V4.07:<br>
  61:../SSC/Src/sdoserv.c **** V4.08 SDO 1: For an upload segment response the toggle bit was overwritten<br>
  62:../SSC/Src/sdoserv.c **** V4.08 SDO 2: For a segmented response the command was wrong in the response<br>
  63:../SSC/Src/sdoserv.c **** <br>Changes to version V4.06:<br>
  64:../SSC/Src/sdoserv.c **** V4.07 SDO 1: In SdoRes the command specifier was not set correctly in case of an abort<br>
  65:../SSC/Src/sdoserv.c **** V4.07 ECAT 1: The sources for SPI and MCI were merged (in ecat_def.h<br>
  66:../SSC/Src/sdoserv.c ****                    set the switch MCI_HW to 1 when using the MCI,<br>
  67:../SSC/Src/sdoserv.c ****                    set the switch SPI_HW to 1 when using the SPI<br>
  68:../SSC/Src/sdoserv.c **** <br>Changes to version V4.05:<br>
  69:../SSC/Src/sdoserv.c **** V4.06 SDO 1: The variable dataSize was used wrong in function SdoRes<br>
  70:../SSC/Src/sdoserv.c **** <br>Changes to version V4.03:<br>
  71:../SSC/Src/sdoserv.c **** V4.04 SDO 1: The SDO interface was changed in that way that a SDO response<br>
  72:../SSC/Src/sdoserv.c ****              could be sent by the application to a later time. In that case<br>
  73:../SSC/Src/sdoserv.c ****                  the functions OBJ_Read and OBJ_Write shall return the value<br>
  74:../SSC/Src/sdoserv.c ****                  ABORTIDX_WORKING. To send the SDO response the new function SDOS_SdoRes<br>
  75:../SSC/Src/sdoserv.c ****                  has to be called by the application. While waiting for the call<br>
  76:../SSC/Src/sdoserv.c ****                  of SDOS_SdoRes the SDO interface will answer to another SDO request<br>
  77:../SSC/Src/sdoserv.c ****                  with the error MBXERR_SERVICEINWORK in the mailbox protocol <br>
  78:../SSC/Src/sdoserv.c **** <br>Changes to version V3.20:<br>
  79:../SSC/Src/sdoserv.c **** V4.00 SDO 1: The size of the written data in case of a SDO Download will be<br>
  80:../SSC/Src/sdoserv.c ****              in the function OBJ_Write to be more flexible<br>
  81:../SSC/Src/sdoserv.c **** V4.00 SDO 2: The object lists will be generated in the functions OBJ_GetNoOfObjects<br>
  82:../SSC/Src/sdoserv.c ****              and OBJ_GetObjectList in objdef.c to decouple the SDO services from<br>
  83:../SSC/Src/sdoserv.c ****              the implementation of the object dictionary<br>
  84:../SSC/Src/sdoserv.c **** V4.00 SDO 3: The name of an object or entry description will only be transmitted<br>
  85:../SSC/Src/sdoserv.c ****              if it fits in the mailbox because the fragmentation is not supported in the sample cod
  86:../SSC/Src/sdoserv.c **** V4.00 SDO 4: SDOs with size greater than 65535 were not handled correctly, that is fixed now
  87:../SSC/Src/sdoserv.c **** */
  88:../SSC/Src/sdoserv.c **** 
  89:../SSC/Src/sdoserv.c **** /*---------------------------------------------------------------------------------------
  90:../SSC/Src/sdoserv.c **** ------
  91:../SSC/Src/sdoserv.c **** ------    Includes
  92:../SSC/Src/sdoserv.c **** ------
  93:../SSC/Src/sdoserv.c **** ---------------------------------------------------------------------------------------*/
  94:../SSC/Src/sdoserv.c **** 
  95:../SSC/Src/sdoserv.c **** #include "ecat_def.h"
  96:../SSC/Src/sdoserv.c **** 
  97:../SSC/Src/sdoserv.c **** #include "ecatslv.h"
  98:../SSC/Src/sdoserv.c **** 
  99:../SSC/Src/sdoserv.c **** #define _SDOSERV_ 1
 100:../SSC/Src/sdoserv.c **** #include "objdef.h"
 101:../SSC/Src/sdoserv.c **** #undef  _SDOSERV_
 102:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.11) ECAT10*/
 103:../SSC/Src/sdoserv.c **** /*remove definition of _SDOSERV_ (#ifdef is used in objdef.h)*/
 104:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.11) ECAT10*/
 105:../SSC/Src/sdoserv.c **** 
 106:../SSC/Src/sdoserv.c **** 
 107:../SSC/Src/sdoserv.c **** 
 108:../SSC/Src/sdoserv.c **** 
 109:../SSC/Src/sdoserv.c **** extern OBJCONST TOBJECT OBJMEM asObjDef[];
 110:../SSC/Src/sdoserv.c **** extern UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT1
 111:../SSC/Src/sdoserv.c **** extern OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UI
 112:../SSC/Src/sdoserv.c **** extern OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry);
 113:../SSC/Src/sdoserv.c **** 
 114:../SSC/Src/sdoserv.c **** /*---------------------------------------------------------------------------------------
 115:../SSC/Src/sdoserv.c **** ------
 116:../SSC/Src/sdoserv.c **** ------    Modulintern variable definitions
 117:../SSC/Src/sdoserv.c **** ------
 118:../SSC/Src/sdoserv.c **** ---------------------------------------------------------------------------------------*/
 119:../SSC/Src/sdoserv.c **** 
 120:../SSC/Src/sdoserv.c **** const UINT32 MBXMEM cAbortCode[] =
 121:../SSC/Src/sdoserv.c **** {
 122:../SSC/Src/sdoserv.c ****     ABORT_NOERROR,
 123:../SSC/Src/sdoserv.c ****     ABORT_TOGGLE_BIT_NOT_CHANGED,
 124:../SSC/Src/sdoserv.c ****     ABORT_SDO_PROTOCOL_TIMEOUT,
 125:../SSC/Src/sdoserv.c ****     ABORT_COMMAND_SPECIFIER_UNKNOWN,
 126:../SSC/Src/sdoserv.c ****     ABORT_OUT_OF_MEMORY,
 127:../SSC/Src/sdoserv.c ****     ABORT_UNSUPPORTED_ACCESS,
 128:../SSC/Src/sdoserv.c ****     ABORT_WRITE_ONLY_ENTRY,
 129:../SSC/Src/sdoserv.c ****     ABORT_READ_ONLY_ENTRY,
 130:../SSC/Src/sdoserv.c ****     ABORT_OBJECT_NOT_EXISTING,
 131:../SSC/Src/sdoserv.c ****     ABORT_OBJECT_CANT_BE_PDOMAPPED,
 132:../SSC/Src/sdoserv.c ****     ABORT_MAPPED_OBJECTS_EXCEED_PDO,
 133:../SSC/Src/sdoserv.c ****     ABORT_PARAM_IS_INCOMPATIBLE,
 134:../SSC/Src/sdoserv.c ****     ABORT_INTERNAL_DEVICE_INCOMPATIBILITY,
 135:../SSC/Src/sdoserv.c ****     ABORT_HARDWARE_ERROR,
 136:../SSC/Src/sdoserv.c ****     ABORT_PARAM_LENGTH_ERROR,
 137:../SSC/Src/sdoserv.c ****     ABORT_PARAM_LENGTH_TOO_LONG,
 138:../SSC/Src/sdoserv.c ****     ABORT_PARAM_LENGTH_TOO_SHORT,
 139:../SSC/Src/sdoserv.c ****     ABORT_SUBINDEX_NOT_EXISTING,
 140:../SSC/Src/sdoserv.c ****     ABORT_VALUE_EXCEEDED,
 141:../SSC/Src/sdoserv.c ****     ABORT_VALUE_TOO_GREAT,
 142:../SSC/Src/sdoserv.c ****     ABORT_VALUE_TOO_SMALL,
 143:../SSC/Src/sdoserv.c ****     ABORT_MODULE_ID_LIST_NOT_MATCH,
 144:../SSC/Src/sdoserv.c ****     ABORT_MAX_VALUE_IS_LESS_THAN_MIN_VALUE,
 145:../SSC/Src/sdoserv.c ****     ABORT_GENERAL_ERROR,
 146:../SSC/Src/sdoserv.c ****     ABORT_DATA_CANNOT_BE_READ_OR_STORED,
 147:../SSC/Src/sdoserv.c ****     ABORT_DATA_CANNOT_BE_READ_OR_STORED_BECAUSE_OF_LOCAL_CONTROL,
 148:../SSC/Src/sdoserv.c ****     ABORT_DATA_CANNOT_BE_READ_OR_STORED_IN_THIS_STATE,
 149:../SSC/Src/sdoserv.c ****     ABORT_NO_OBJECT_DICTIONARY_IS_PRESENT,
 150:../SSC/Src/sdoserv.c ****     ABORT_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0,
 151:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.11) SDO10*/
 152:../SSC/Src/sdoserv.c ****     ABORT_COMPLETE_ACCESS_NOT_SUPPORTED
 153:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.11) SDO10*/
 154:../SSC/Src/sdoserv.c **** };
 155:../SSC/Src/sdoserv.c **** 
 156:../SSC/Src/sdoserv.c **** UINT16 VARMEM                            nSdoInfoIndex;
 157:../SSC/Src/sdoserv.c **** OBJCONST TOBJECT OBJMEM * VARMEM        pSdoInfoObjEntry;
 158:../SSC/Src/sdoserv.c **** 
 159:../SSC/Src/sdoserv.c **** TINITSDOMBX MBXMEM *    VARMEM            pSdoResStored;
 160:../SSC/Src/sdoserv.c **** BOOL    VARMEM                            bSdoInWork = FALSE;
 161:../SSC/Src/sdoserv.c **** 
 162:../SSC/Src/sdoserv.c **** UINT8    VARMEM                         nSdoSegService;
 163:../SSC/Src/sdoserv.c **** UINT8    VARMEM                         bSdoSegFollows;
 164:../SSC/Src/sdoserv.c **** UINT8    VARMEM                         bSdoSegAccess;
 165:../SSC/Src/sdoserv.c **** UINT16 VARMEM                           nSdoSegIndex;
 166:../SSC/Src/sdoserv.c **** UINT8 VARMEM                            nSdoSegSubindex;
 167:../SSC/Src/sdoserv.c **** UINT32 VARMEM                           nSdoSegBytesToHandle;
 168:../SSC/Src/sdoserv.c **** UINT8 VARMEM                            bSdoSegLastToggle;
 169:../SSC/Src/sdoserv.c **** UINT32 VARMEM                           nSdoSegCompleteSize;
 170:../SSC/Src/sdoserv.c **** OBJCONST TOBJECT OBJMEM * VARMEM        pSdoSegObjEntry;
 171:../SSC/Src/sdoserv.c **** 
 172:../SSC/Src/sdoserv.c **** /*---------------------------------------------------------------------------------------
 173:../SSC/Src/sdoserv.c **** ------
 174:../SSC/Src/sdoserv.c **** ------    module internal function declarations
 175:../SSC/Src/sdoserv.c **** ------
 176:../SSC/Src/sdoserv.c **** ---------------------------------------------------------------------------------------*/
 177:../SSC/Src/sdoserv.c **** static UINT8 SdoDownloadSegmentInd(TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd);
 178:../SSC/Src/sdoserv.c **** static UINT8 SdoUploadSegmentInd(TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd);
 179:../SSC/Src/sdoserv.c **** /*---------------------------------------------------------------------------------------
 180:../SSC/Src/sdoserv.c **** ------
 181:../SSC/Src/sdoserv.c **** ------    Functions
 182:../SSC/Src/sdoserv.c **** ------
 183:../SSC/Src/sdoserv.c **** ---------------------------------------------------------------------------------------*/
 184:../SSC/Src/sdoserv.c **** 
 185:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 186:../SSC/Src/sdoserv.c **** /**
 187:../SSC/Src/sdoserv.c ****  \param     pSdoInd    Pointer to the received mailbox data from the master.
 188:../SSC/Src/sdoserv.c **** 
 189:../SSC/Src/sdoserv.c ****  \return    Indicates if an error occurred while the operation ( good = 0 ).
 190:../SSC/Src/sdoserv.c **** 
 191:../SSC/Src/sdoserv.c ****  \brief    This function is called when a Download SDO Segment request
 192:../SSC/Src/sdoserv.c ****             service is received from the master. If its the last segment
 193:../SSC/Src/sdoserv.c ****             the data will be written to the object dictionary. The
 194:../SSC/Src/sdoserv.c ****             function sends a response by itself.
 195:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 196:../SSC/Src/sdoserv.c **** 
 197:../SSC/Src/sdoserv.c **** static UINT8 SdoDownloadSegmentInd( TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd )
 198:../SSC/Src/sdoserv.c **** {
  91              	 .loc 1 198 0
  92              	 .cfi_startproc
  93              	 
  94              	 
  95 0000 B0B5     	 push {r4,r5,r7,lr}
  96              	.LCFI0:
  97              	 .cfi_def_cfa_offset 16
  98              	 .cfi_offset 4,-16
  99              	 .cfi_offset 5,-12
 100              	 .cfi_offset 7,-8
 101              	 .cfi_offset 14,-4
 102 0002 88B0     	 sub sp,sp,#32
 103              	.LCFI1:
 104              	 .cfi_def_cfa_offset 48
 105 0004 02AF     	 add r7,sp,#8
 106              	.LCFI2:
 107              	 .cfi_def_cfa 7,40
 108 0006 7860     	 str r0,[r7,#4]
 199:../SSC/Src/sdoserv.c ****     UINT8 abort = 0;
 109              	 .loc 1 199 0
 110 0008 0023     	 movs r3,#0
 111 000a FB75     	 strb r3,[r7,#23]
 200:../SSC/Src/sdoserv.c ****     UINT32 bytesToSave = 0;
 112              	 .loc 1 200 0
 113 000c 0023     	 movs r3,#0
 114 000e 3B61     	 str r3,[r7,#16]
 201:../SSC/Src/sdoserv.c **** 
 202:../SSC/Src/sdoserv.c ****     if ( (pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle )
 115              	 .loc 1 202 0
 116 0010 7B68     	 ldr r3,[r7,#4]
 117 0012 1B7A     	 ldrb r3,[r3,#8]
 118 0014 03F01003 	 and r3,r3,#16
 119 0018 864A     	 ldr r2,.L24
 120 001a 1278     	 ldrb r2,[r2]
 121 001c 9342     	 cmp r3,r2
 122 001e 02D1     	 bne .L2
 203:../SSC/Src/sdoserv.c ****     {
 204:../SSC/Src/sdoserv.c ****         /* toggle bit has not toggled... */
 205:../SSC/Src/sdoserv.c ****         abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
 123              	 .loc 1 205 0
 124 0020 0123     	 movs r3,#1
 125 0022 FB75     	 strb r3,[r7,#23]
 126 0024 BBE0     	 b .L3
 127              	.L2:
 128              	.LBB2:
 206:../SSC/Src/sdoserv.c ****     }
 207:../SSC/Src/sdoserv.c ****     else
 208:../SSC/Src/sdoserv.c ****     {
 209:../SSC/Src/sdoserv.c ****         /* maxData contains the maximum data to be received with a SDO-DownloadSegment */
 210:../SSC/Src/sdoserv.c ****         UINT16 maxData =    u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
 129              	 .loc 1 210 0
 130 0026 844B     	 ldr r3,.L24+4
 131 0028 1B88     	 ldrh r3,[r3]
 132 002a 093B     	 subs r3,r3,#9
 133 002c FB81     	 strh r3,[r7,#14]
 211:../SSC/Src/sdoserv.c ****         /* the new toggle bit is stored in bSdoSegLastToggle */
 212:../SSC/Src/sdoserv.c ****         bSdoSegLastToggle = pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE;
 134              	 .loc 1 212 0
 135 002e 7B68     	 ldr r3,[r7,#4]
 136 0030 1B7A     	 ldrb r3,[r3,#8]
 137 0032 03F01003 	 and r3,r3,#16
 138 0036 DAB2     	 uxtb r2,r3
 139 0038 7E4B     	 ldr r3,.L24
 140 003a 1A70     	 strb r2,[r3]
 213:../SSC/Src/sdoserv.c **** 
 214:../SSC/Src/sdoserv.c ****         /* a SDO-Download Segment is only allowed if a SDO-Download Request was received before,
 215:../SSC/Src/sdoserv.c ****            in that case a buffer for the received data was allocated in SDOS_SdoInd before */
 216:../SSC/Src/sdoserv.c ****         if ( pSdoSegData )
 141              	 .loc 1 216 0
 142 003c 7F4B     	 ldr r3,.L24+8
 143 003e 1B68     	 ldr r3,[r3]
 144 0040 002B     	 cmp r3,#0
 145 0042 00F0AA80 	 beq .L4
 217:../SSC/Src/sdoserv.c ****         {
 218:../SSC/Src/sdoserv.c ****             /* bytesToSave contains the remaining data with this and maybe the following
 219:../SSC/Src/sdoserv.c ****                SDO-Download Segment services */
 220:../SSC/Src/sdoserv.c ****             bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
 146              	 .loc 1 220 0
 147 0046 7E4B     	 ldr r3,.L24+12
 148 0048 1A68     	 ldr r2,[r3]
 149 004a 7E4B     	 ldr r3,.L24+16
 150 004c 1B68     	 ldr r3,[r3]
 151 004e D31A     	 subs r3,r2,r3
 152 0050 3B61     	 str r3,[r7,#16]
 221:../SSC/Src/sdoserv.c **** 
 222:../SSC/Src/sdoserv.c ****             if ( pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS )
 153              	 .loc 1 222 0
 154 0052 7B68     	 ldr r3,[r7,#4]
 155 0054 1B7A     	 ldrb r3,[r3,#8]
 156 0056 03F00103 	 and r3,r3,#1
 157 005a 002B     	 cmp r3,#0
 158 005c 2CD0     	 beq .L5
 223:../SSC/Src/sdoserv.c ****             {
 224:../SSC/Src/sdoserv.c ****                 /* the last segment is received, check if the length of the remaining data is the
 225:../SSC/Src/sdoserv.c ****                    same as the length of the received data */
 226:../SSC/Src/sdoserv.c ****                 if ( bytesToSave <= maxData )
 159              	 .loc 1 226 0
 160 005e FA89     	 ldrh r2,[r7,#14]
 161 0060 3B69     	 ldr r3,[r7,#16]
 162 0062 9A42     	 cmp r2,r3
 163 0064 25D3     	 bcc .L6
 164              	.LBB3:
 227:../SSC/Src/sdoserv.c ****                 {
 228:../SSC/Src/sdoserv.c **** /* ECATCHANGE_START(V5.11) ECAT7*/
 229:../SSC/Src/sdoserv.c ****                     UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
 165              	 .loc 1 229 0
 166 0066 7B68     	 ldr r3,[r7,#4]
 167 0068 1B88     	 ldrh r3,[r3]
 168 006a BB81     	 strh r3,[r7,#12]
 230:../SSC/Src/sdoserv.c **** 
 231:../SSC/Src/sdoserv.c ****                     /* for the check it is distinguished if the remaining bytes are less than 8 (in
 232:../SSC/Src/sdoserv.c ****                        case 7 data bytes were sent and the SDO-Download Segment header contains the
 233:../SSC/Src/sdoserv.c ****                         how much bytes are valid (CAN-compatibility)), otherwise the length has to 
 234:../SSC/Src/sdoserv.c ****                         and the SDO-Download Segment-Headerbyte is ignored */
 235:../SSC/Src/sdoserv.c ****                     if (((bytesToSave <= (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
 169              	 .loc 1 235 0
 170 006c BB89     	 ldrh r3,[r7,#12]
 171 006e 033B     	 subs r3,r3,#3
 172 0070 1A46     	 mov r2,r3
 173 0072 3B69     	 ldr r3,[r7,#16]
 174 0074 9A42     	 cmp r2,r3
 175 0076 0CD3     	 bcc .L7
 236:../SSC/Src/sdoserv.c ****                          &&( bytesToSave == ((UINT16) (MIN_SEGMENTED_DATA - ((pSdoInd->SdoHeader.Se
 176              	 .loc 1 236 0
 177 0078 7B68     	 ldr r3,[r7,#4]
 178 007a 1B7A     	 ldrb r3,[r3,#8]
 179 007c 03F00E03 	 and r3,r3,#14
 180 0080 5B10     	 asrs r3,r3,#1
 181 0082 9BB2     	 uxth r3,r3
 182 0084 C3F10703 	 rsb r3,r3,#7
 183 0088 9BB2     	 uxth r3,r3
 184 008a 1A46     	 mov r2,r3
 185 008c 3B69     	 ldr r3,[r7,#16]
 186 008e 9A42     	 cmp r2,r3
 187 0090 08D0     	 beq .L8
 188              	.L7:
 237:../SSC/Src/sdoserv.c ****                           )
 238:../SSC/Src/sdoserv.c ****                         ||( ( bytesToSave > MIN_SEGMENTED_DATA )
 189              	 .loc 1 238 0
 190 0092 3B69     	 ldr r3,[r7,#16]
 191 0094 072B     	 cmp r3,#7
 192 0096 09D9     	 bls .L9
 239:../SSC/Src/sdoserv.c ****                         && (bytesToSave == (mbxSize - SEGMENT_NORM_HEADER_SIZE))
 193              	 .loc 1 239 0
 194 0098 BB89     	 ldrh r3,[r7,#12]
 195 009a 033B     	 subs r3,r3,#3
 196 009c 1A46     	 mov r2,r3
 197 009e 3B69     	 ldr r3,[r7,#16]
 198 00a0 9A42     	 cmp r2,r3
 199 00a2 03D1     	 bne .L9
 200              	.L8:
 240:../SSC/Src/sdoserv.c ****                         ) )
 241:../SSC/Src/sdoserv.c **** /* ECATCHANGE_END(V5.11) ECAT7*/
 242:../SSC/Src/sdoserv.c ****                     {
 243:../SSC/Src/sdoserv.c ****                         /* length is correct */
 244:../SSC/Src/sdoserv.c ****                         bSdoSegFollows = FALSE;
 201              	 .loc 1 244 0
 202 00a4 684B     	 ldr r3,.L24+20
 203 00a6 0022     	 movs r2,#0
 204 00a8 1A70     	 strb r2,[r3]
 205 00aa 11E0     	 b .L12
 206              	.L9:
 245:../SSC/Src/sdoserv.c ****                     }
 246:../SSC/Src/sdoserv.c ****                     else
 247:../SSC/Src/sdoserv.c ****                         abort = ABORTIDX_PARAM_LENGTH_ERROR;
 207              	 .loc 1 247 0
 208 00ac 0E23     	 movs r3,#14
 209 00ae FB75     	 strb r3,[r7,#23]
 210              	.LBE3:
 211 00b0 0EE0     	 b .L12
 212              	.L6:
 248:../SSC/Src/sdoserv.c ****                 }
 249:../SSC/Src/sdoserv.c ****                 else
 250:../SSC/Src/sdoserv.c ****                     abort = ABORTIDX_PARAM_LENGTH_ERROR;
 213              	 .loc 1 250 0
 214 00b2 0E23     	 movs r3,#14
 215 00b4 FB75     	 strb r3,[r7,#23]
 216 00b6 0BE0     	 b .L12
 217              	.L5:
 251:../SSC/Src/sdoserv.c ****             }
 252:../SSC/Src/sdoserv.c ****             else
 253:../SSC/Src/sdoserv.c ****             {
 254:../SSC/Src/sdoserv.c ****                 /* its not the last segment */
 255:../SSC/Src/sdoserv.c ****                 bSdoSegFollows = TRUE;
 218              	 .loc 1 255 0
 219 00b8 634B     	 ldr r3,.L24+20
 220 00ba 0122     	 movs r2,#1
 221 00bc 1A70     	 strb r2,[r3]
 256:../SSC/Src/sdoserv.c ****                 /* we have to check if we expect less bytes than the maximum size which can be send
 257:../SSC/Src/sdoserv.c ****                    SDO Download Segment */
 258:../SSC/Src/sdoserv.c ****                 if ( bytesToSave <= maxData )
 222              	 .loc 1 258 0
 223 00be FA89     	 ldrh r2,[r7,#14]
 224 00c0 3B69     	 ldr r3,[r7,#16]
 225 00c2 9A42     	 cmp r2,r3
 226 00c4 02D3     	 bcc .L13
 259:../SSC/Src/sdoserv.c ****                     abort = ABORTIDX_PARAM_LENGTH_ERROR;
 227              	 .loc 1 259 0
 228 00c6 0E23     	 movs r3,#14
 229 00c8 FB75     	 strb r3,[r7,#23]
 230 00ca 01E0     	 b .L12
 231              	.L13:
 260:../SSC/Src/sdoserv.c ****                 else
 261:../SSC/Src/sdoserv.c ****                     /* length is okay, bytesToSave contains the data size to be copied */
 262:../SSC/Src/sdoserv.c ****                     bytesToSave = maxData;
 232              	 .loc 1 262 0
 233 00cc FB89     	 ldrh r3,[r7,#14]
 234 00ce 3B61     	 str r3,[r7,#16]
 235              	.L12:
 263:../SSC/Src/sdoserv.c ****             }
 264:../SSC/Src/sdoserv.c **** 
 265:../SSC/Src/sdoserv.c ****             if ( abort == 0 )
 236              	 .loc 1 265 0
 237 00d0 FB7D     	 ldrb r3,[r7,#23]
 238 00d2 002B     	 cmp r3,#0
 239 00d4 63D1     	 bne .L3
 266:../SSC/Src/sdoserv.c ****             {
 267:../SSC/Src/sdoserv.c ****                 /* the received data is copied in the buffer */
 268:../SSC/Src/sdoserv.c ****                 MBXMEMCPY( ((UINT8*)pSdoSegData) + (nSdoSegBytesToHandle), pSdoInd->SdoHeader.Data,
 240              	 .loc 1 268 0
 241 00d6 594B     	 ldr r3,.L24+8
 242 00d8 1A68     	 ldr r2,[r3]
 243 00da 5A4B     	 ldr r3,.L24+16
 244 00dc 1B68     	 ldr r3,[r3]
 245 00de 1A44     	 add r2,r2,r3
 246 00e0 7B68     	 ldr r3,[r7,#4]
 247 00e2 0933     	 adds r3,r3,#9
 248 00e4 1046     	 mov r0,r2
 249 00e6 1946     	 mov r1,r3
 250 00e8 3A69     	 ldr r2,[r7,#16]
 251 00ea FFF7FEFF 	 bl memcpy
 269:../SSC/Src/sdoserv.c **** 
 270:../SSC/Src/sdoserv.c ****                 if ( bSdoSegFollows == FALSE    )
 252              	 .loc 1 270 0
 253 00ee 564B     	 ldr r3,.L24+20
 254 00f0 1B78     	 ldrb r3,[r3]
 255 00f2 002B     	 cmp r3,#0
 256 00f4 53D1     	 bne .L3
 271:../SSC/Src/sdoserv.c ****                 {
 272:../SSC/Src/sdoserv.c ****                     /* it was the last segment, OBJ_Write will called to make the Write-operation *
 273:../SSC/Src/sdoserv.c ****                     abort = OBJ_Write( nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegO
 257              	 .loc 1 273 0
 258 00f6 554B     	 ldr r3,.L24+24
 259 00f8 1888     	 ldrh r0,[r3]
 260 00fa 554B     	 ldr r3,.L24+28
 261 00fc 1978     	 ldrb r1,[r3]
 262 00fe 504B     	 ldr r3,.L24+12
 263 0100 1D68     	 ldr r5,[r3]
 264 0102 544B     	 ldr r3,.L24+32
 265 0104 1C68     	 ldr r4,[r3]
 266 0106 4D4B     	 ldr r3,.L24+8
 267 0108 1A68     	 ldr r2,[r3]
 268 010a 534B     	 ldr r3,.L24+36
 269 010c 1B78     	 ldrb r3,[r3]
 270 010e 0092     	 str r2,[sp]
 271 0110 0193     	 str r3,[sp,#4]
 272 0112 2A46     	 mov r2,r5
 273 0114 2346     	 mov r3,r4
 274 0116 FFF7FEFF 	 bl OBJ_Write
 275 011a 0346     	 mov r3,r0
 276 011c FB75     	 strb r3,[r7,#23]
 274:../SSC/Src/sdoserv.c ****                     if ( abort == ABORTIDX_WORKING )
 277              	 .loc 1 274 0
 278 011e FB7D     	 ldrb r3,[r7,#23]
 279 0120 FF2B     	 cmp r3,#255
 280 0122 31D1     	 bne .L15
 275:../SSC/Src/sdoserv.c ****                     {
 276:../SSC/Src/sdoserv.c ****                         /* the application generates the SDO-Response later on by calling SDOS_SdoR
 277:../SSC/Src/sdoserv.c ****                         u8PendingSdo = SDO_PENDING_SEG_WRITE;
 281              	 .loc 1 277 0
 282 0124 4D4B     	 ldr r3,.L24+40
 283 0126 0222     	 movs r2,#2
 284 0128 1A70     	 strb r2,[r3]
 278:../SSC/Src/sdoserv.c ****                         bStoreCompleteAccess = bSdoSegAccess;
 285              	 .loc 1 278 0
 286 012a 4B4B     	 ldr r3,.L24+36
 287 012c 1B78     	 ldrb r3,[r3]
 288 012e 002B     	 cmp r3,#0
 289 0130 14BF     	 ite ne
 290 0132 0123     	 movne r3,#1
 291 0134 0023     	 moveq r3,#0
 292 0136 DAB2     	 uxtb r2,r3
 293 0138 494B     	 ldr r3,.L24+44
 294 013a 1A70     	 strb r2,[r3]
 279:../SSC/Src/sdoserv.c ****                         u8StoreSubindex = nSdoSegSubindex;
 295              	 .loc 1 279 0
 296 013c 444B     	 ldr r3,.L24+28
 297 013e 1A78     	 ldrb r2,[r3]
 298 0140 484B     	 ldr r3,.L24+48
 299 0142 1A70     	 strb r2,[r3]
 280:../SSC/Src/sdoserv.c ****                         u16StoreIndex = nSdoSegIndex;
 300              	 .loc 1 280 0
 301 0144 414B     	 ldr r3,.L24+24
 302 0146 1A88     	 ldrh r2,[r3]
 303 0148 474B     	 ldr r3,.L24+52
 304 014a 1A80     	 strh r2,[r3]
 281:../SSC/Src/sdoserv.c ****                         u32StoreDataSize = nSdoSegCompleteSize;
 305              	 .loc 1 281 0
 306 014c 3C4B     	 ldr r3,.L24+12
 307 014e 1B68     	 ldr r3,[r3]
 308 0150 464A     	 ldr r2,.L24+56
 309 0152 1360     	 str r3,[r2]
 282:../SSC/Src/sdoserv.c ****                         pStoreData = pSdoSegData;
 310              	 .loc 1 282 0
 311 0154 394B     	 ldr r3,.L24+8
 312 0156 1B68     	 ldr r3,[r3]
 313 0158 454A     	 ldr r2,.L24+60
 314 015a 1360     	 str r3,[r2]
 283:../SSC/Src/sdoserv.c **** 
 284:../SSC/Src/sdoserv.c ****                         pSdoPendFunc = pSdoSegObjEntry->Write;
 315              	 .loc 1 284 0
 316 015c 3D4B     	 ldr r3,.L24+32
 317 015e 1B68     	 ldr r3,[r3]
 318 0160 1B6A     	 ldr r3,[r3,#32]
 319 0162 444A     	 ldr r2,.L24+64
 320 0164 1360     	 str r3,[r2]
 285:../SSC/Src/sdoserv.c **** 
 286:../SSC/Src/sdoserv.c ****                         bSdoInWork = TRUE;
 321              	 .loc 1 286 0
 322 0166 444B     	 ldr r3,.L24+68
 323 0168 0122     	 movs r2,#1
 324 016a 1A70     	 strb r2,[r3]
 287:../SSC/Src/sdoserv.c ****                         pSdoResStored = (TINITSDOMBX MBXMEM *) pSdoInd;
 325              	 .loc 1 287 0
 326 016c 434A     	 ldr r2,.L24+72
 327 016e 7B68     	 ldr r3,[r7,#4]
 328 0170 1360     	 str r3,[r2]
 288:../SSC/Src/sdoserv.c **** 
 289:../SSC/Src/sdoserv.c ****                         bSdoSegFollows = FALSE;
 329              	 .loc 1 289 0
 330 0172 354B     	 ldr r3,.L24+20
 331 0174 0022     	 movs r2,#0
 332 0176 1A70     	 strb r2,[r3]
 290:../SSC/Src/sdoserv.c ****                         nSdoSegService    = 0;
 333              	 .loc 1 290 0
 334 0178 414B     	 ldr r3,.L24+76
 335 017a 0022     	 movs r2,#0
 336 017c 1A70     	 strb r2,[r3]
 291:../SSC/Src/sdoserv.c ****                         nSdoSegBytesToHandle = 0;
 337              	 .loc 1 291 0
 338 017e 314B     	 ldr r3,.L24+16
 339 0180 0022     	 movs r2,#0
 340 0182 1A60     	 str r2,[r3]
 292:../SSC/Src/sdoserv.c **** 
 293:../SSC/Src/sdoserv.c ****                         return ABORTIDX_WORKING;
 341              	 .loc 1 293 0
 342 0184 FF23     	 movs r3,#255
 343 0186 51E0     	 b .L16
 344              	.L15:
 294:../SSC/Src/sdoserv.c ****                     }
 295:../SSC/Src/sdoserv.c ****                     else
 296:../SSC/Src/sdoserv.c ****                     {
 297:../SSC/Src/sdoserv.c ****                         /* the allocated buffer can be released */
 298:../SSC/Src/sdoserv.c ****                         FREEMEM( (UINT16 VARMEM *) pSdoSegData );
 345              	 .loc 1 298 0
 346 0188 2C4B     	 ldr r3,.L24+8
 347 018a 1B68     	 ldr r3,[r3]
 348 018c 1846     	 mov r0,r3
 349 018e FFF7FEFF 	 bl free
 299:../SSC/Src/sdoserv.c ****                         pSdoSegData = NULL;
 350              	 .loc 1 299 0
 351 0192 2A4B     	 ldr r3,.L24+8
 352 0194 0022     	 movs r2,#0
 353 0196 1A60     	 str r2,[r3]
 354 0198 01E0     	 b .L3
 355              	.L4:
 300:../SSC/Src/sdoserv.c ****                     }
 301:../SSC/Src/sdoserv.c ****                 }
 302:../SSC/Src/sdoserv.c ****             }
 303:../SSC/Src/sdoserv.c ****         }
 304:../SSC/Src/sdoserv.c ****         else
 305:../SSC/Src/sdoserv.c ****         {
 306:../SSC/Src/sdoserv.c ****             abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 356              	 .loc 1 306 0
 357 019a 0323     	 movs r3,#3
 358 019c FB75     	 strb r3,[r7,#23]
 359              	.L3:
 360              	.LBE2:
 307:../SSC/Src/sdoserv.c ****         }
 308:../SSC/Src/sdoserv.c ****     }
 309:../SSC/Src/sdoserv.c **** 
 310:../SSC/Src/sdoserv.c ****     if ( abort == 0)
 361              	 .loc 1 310 0
 362 019e FB7D     	 ldrb r3,[r7,#23]
 363 01a0 002B     	 cmp r3,#0
 364 01a2 2DD1     	 bne .L17
 311:../SSC/Src/sdoserv.c ****     {
 312:../SSC/Src/sdoserv.c ****         /* send the SDO Download Segment response */
 313:../SSC/Src/sdoserv.c ****         pSdoInd->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
 365              	 .loc 1 313 0
 366 01a4 7B68     	 ldr r3,[r7,#4]
 367 01a6 0A22     	 movs r2,#10
 368 01a8 1A80     	 strh r2,[r3]
 314:../SSC/Src/sdoserv.c ****         pSdoInd->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 369              	 .loc 1 314 0
 370 01aa 7B68     	 ldr r3,[r7,#4]
 371 01ac DB88     	 ldrh r3,[r3,#6]
 372 01ae C3F30B03 	 ubfx r3,r3,#0,#12
 373 01b2 9AB2     	 uxth r2,r3
 374 01b4 7B68     	 ldr r3,[r7,#4]
 375 01b6 DA80     	 strh r2,[r3,#6]
 315:../SSC/Src/sdoserv.c ****         pSdoInd->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
 376              	 .loc 1 315 0
 377 01b8 7B68     	 ldr r3,[r7,#4]
 378 01ba DB88     	 ldrh r3,[r3,#6]
 379 01bc 43F44053 	 orr r3,r3,#12288
 380 01c0 9AB2     	 uxth r2,r3
 381 01c2 7B68     	 ldr r3,[r7,#4]
 382 01c4 DA80     	 strh r2,[r3,#6]
 316:../SSC/Src/sdoserv.c ****         /* the SDO Download Segment header depends if it was the last segment or not */
 317:../SSC/Src/sdoserv.c ****         if ( bSdoSegLastToggle )
 383              	 .loc 1 317 0
 384 01c6 1B4B     	 ldr r3,.L24
 385 01c8 1B78     	 ldrb r3,[r3]
 386 01ca 002B     	 cmp r3,#0
 387 01cc 03D0     	 beq .L18
 318:../SSC/Src/sdoserv.c ****         {
 319:../SSC/Src/sdoserv.c ****            pSdoInd->SdoHeader.SegHeader        = SDOSERVICE_DOWNLOADSEGMENTRES|SEGHEADER_TOGGLE;
 388              	 .loc 1 319 0
 389 01ce 7B68     	 ldr r3,[r7,#4]
 390 01d0 3022     	 movs r2,#48
 391 01d2 1A72     	 strb r2,[r3,#8]
 392 01d4 02E0     	 b .L19
 393              	.L18:
 320:../SSC/Src/sdoserv.c ****         }
 321:../SSC/Src/sdoserv.c ****         else
 322:../SSC/Src/sdoserv.c ****            pSdoInd->SdoHeader.SegHeader        = SDOSERVICE_DOWNLOADSEGMENTRES;
 394              	 .loc 1 322 0
 395 01d6 7B68     	 ldr r3,[r7,#4]
 396 01d8 2022     	 movs r2,#32
 397 01da 1A72     	 strb r2,[r3,#8]
 398              	.L19:
 323:../SSC/Src/sdoserv.c **** 
 324:../SSC/Src/sdoserv.c ****         if ( bSdoSegFollows == TRUE )
 399              	 .loc 1 324 0
 400 01dc 1A4B     	 ldr r3,.L24+20
 401 01de 1B78     	 ldrb r3,[r3]
 402 01e0 012B     	 cmp r3,#1
 403 01e2 06D1     	 bne .L20
 325:../SSC/Src/sdoserv.c ****         {
 326:../SSC/Src/sdoserv.c ****             /* segments are still expected, nSdoSegBytesToHandle contains the number of received da
 327:../SSC/Src/sdoserv.c ****             nSdoSegBytesToHandle += bytesToSave;
 404              	 .loc 1 327 0
 405 01e4 174B     	 ldr r3,.L24+16
 406 01e6 1A68     	 ldr r2,[r3]
 407 01e8 3B69     	 ldr r3,[r7,#16]
 408 01ea 1344     	 add r3,r3,r2
 409 01ec 154A     	 ldr r2,.L24+16
 410 01ee 1360     	 str r3,[r2]
 411 01f0 1BE0     	 b .L22
 412              	.L20:
 328:../SSC/Src/sdoserv.c ****         }
 329:../SSC/Src/sdoserv.c ****         else
 330:../SSC/Src/sdoserv.c ****         {
 331:../SSC/Src/sdoserv.c ****             /* the last segment was received, the variables are reset */
 332:../SSC/Src/sdoserv.c ****             nSdoSegBytesToHandle = 0;
 413              	 .loc 1 332 0
 414 01f2 144B     	 ldr r3,.L24+16
 415 01f4 0022     	 movs r2,#0
 416 01f6 1A60     	 str r2,[r3]
 333:../SSC/Src/sdoserv.c ****             nSdoSegService    = 0;
 417              	 .loc 1 333 0
 418 01f8 214B     	 ldr r3,.L24+76
 419 01fa 0022     	 movs r2,#0
 420 01fc 1A70     	 strb r2,[r3]
 421 01fe 14E0     	 b .L22
 422              	.L17:
 334:../SSC/Src/sdoserv.c ****         }
 335:../SSC/Src/sdoserv.c ****     }
 336:../SSC/Src/sdoserv.c ****     else 
 337:../SSC/Src/sdoserv.c ****     {
 338:../SSC/Src/sdoserv.c ****         /* the Abort-Response will be sent in SDOS_SdoInd*/
 339:../SSC/Src/sdoserv.c ****         bSdoSegFollows = FALSE;
 423              	 .loc 1 339 0
 424 0200 114B     	 ldr r3,.L24+20
 425 0202 0022     	 movs r2,#0
 426 0204 1A70     	 strb r2,[r3]
 340:../SSC/Src/sdoserv.c ****         nSdoSegService    = 0;
 427              	 .loc 1 340 0
 428 0206 1E4B     	 ldr r3,.L24+76
 429 0208 0022     	 movs r2,#0
 430 020a 1A70     	 strb r2,[r3]
 341:../SSC/Src/sdoserv.c ****         if (pSdoSegData)
 431              	 .loc 1 341 0
 432 020c 0B4B     	 ldr r3,.L24+8
 433 020e 1B68     	 ldr r3,[r3]
 434 0210 002B     	 cmp r3,#0
 435 0212 07D0     	 beq .L23
 342:../SSC/Src/sdoserv.c ****         {
 343:../SSC/Src/sdoserv.c ****             /* the memory has to be released if it is not released before.
 344:../SSC/Src/sdoserv.c ****             In case of AbortIdx_Working the buffer will be freed in SDOS_SdoRes*/
 345:../SSC/Src/sdoserv.c ****             FREEMEM( (UINT16 VARMEM *) pSdoSegData );
 436              	 .loc 1 345 0
 437 0214 094B     	 ldr r3,.L24+8
 438 0216 1B68     	 ldr r3,[r3]
 439 0218 1846     	 mov r0,r3
 440 021a FFF7FEFF 	 bl free
 346:../SSC/Src/sdoserv.c ****             pSdoSegData = NULL;
 441              	 .loc 1 346 0
 442 021e 074B     	 ldr r3,.L24+8
 443 0220 0022     	 movs r2,#0
 444 0222 1A60     	 str r2,[r3]
 445              	.L23:
 347:../SSC/Src/sdoserv.c ****         }
 348:../SSC/Src/sdoserv.c **** 
 349:../SSC/Src/sdoserv.c ****         nSdoSegBytesToHandle = 0;
 446              	 .loc 1 349 0
 447 0224 074B     	 ldr r3,.L24+16
 448 0226 0022     	 movs r2,#0
 449 0228 1A60     	 str r2,[r3]
 450              	.L22:
 350:../SSC/Src/sdoserv.c ****     }
 351:../SSC/Src/sdoserv.c **** 
 352:../SSC/Src/sdoserv.c ****     return abort;
 451              	 .loc 1 352 0
 452 022a FB7D     	 ldrb r3,[r7,#23]
 453              	.L16:
 353:../SSC/Src/sdoserv.c **** }
 454              	 .loc 1 353 0
 455 022c 1846     	 mov r0,r3
 456 022e 1837     	 adds r7,r7,#24
 457              	.LCFI3:
 458              	 .cfi_def_cfa_offset 16
 459 0230 BD46     	 mov sp,r7
 460              	.LCFI4:
 461              	 .cfi_def_cfa_register 13
 462              	 
 463 0232 B0BD     	 pop {r4,r5,r7,pc}
 464              	.L25:
 465              	 .align 2
 466              	.L24:
 467 0234 00000000 	 .word bSdoSegLastToggle
 468 0238 00000000 	 .word u16ReceiveMbxSize
 469 023c 00000000 	 .word pSdoSegData
 470 0240 00000000 	 .word nSdoSegCompleteSize
 471 0244 00000000 	 .word nSdoSegBytesToHandle
 472 0248 00000000 	 .word bSdoSegFollows
 473 024c 00000000 	 .word nSdoSegIndex
 474 0250 00000000 	 .word nSdoSegSubindex
 475 0254 00000000 	 .word pSdoSegObjEntry
 476 0258 00000000 	 .word bSdoSegAccess
 477 025c 00000000 	 .word u8PendingSdo
 478 0260 00000000 	 .word bStoreCompleteAccess
 479 0264 00000000 	 .word u8StoreSubindex
 480 0268 00000000 	 .word u16StoreIndex
 481 026c 00000000 	 .word u32StoreDataSize
 482 0270 00000000 	 .word pStoreData
 483 0274 00000000 	 .word pSdoPendFunc
 484 0278 00000000 	 .word bSdoInWork
 485 027c 00000000 	 .word pSdoResStored
 486 0280 00000000 	 .word nSdoSegService
 487              	 .cfi_endproc
 488              	.LFE172:
 490              	 .section .text.SdoUploadSegmentInd,"ax",%progbits
 491              	 .align 2
 492              	 .thumb
 493              	 .thumb_func
 495              	SdoUploadSegmentInd:
 496              	.LFB173:
 354:../SSC/Src/sdoserv.c **** 
 355:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 356:../SSC/Src/sdoserv.c **** /**
 357:../SSC/Src/sdoserv.c ****  \param     pSdoInd            Pointer to the received mailbox data from the master.
 358:../SSC/Src/sdoserv.c **** 
 359:../SSC/Src/sdoserv.c ****  \return    Indicates if an error occurred while the operation ( good = 0 ).
 360:../SSC/Src/sdoserv.c **** 
 361:../SSC/Src/sdoserv.c ****  \brief    This function is called when a Upload SDO Segment request service
 362:../SSC/Src/sdoserv.c ****             is received from the master. It prepares and operates the
 363:../SSC/Src/sdoserv.c ****             response and sends it by itself.
 364:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 365:../SSC/Src/sdoserv.c **** 
 366:../SSC/Src/sdoserv.c **** static UINT8 SdoUploadSegmentInd( TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd )
 367:../SSC/Src/sdoserv.c **** {
 497              	 .loc 1 367 0
 498              	 .cfi_startproc
 499              	 
 500              	 
 501 0000 80B5     	 push {r7,lr}
 502              	.LCFI5:
 503              	 .cfi_def_cfa_offset 8
 504              	 .cfi_offset 7,-8
 505              	 .cfi_offset 14,-4
 506 0002 86B0     	 sub sp,sp,#24
 507              	.LCFI6:
 508              	 .cfi_def_cfa_offset 32
 509 0004 00AF     	 add r7,sp,#0
 510              	.LCFI7:
 511              	 .cfi_def_cfa_register 7
 512 0006 7860     	 str r0,[r7,#4]
 368:../SSC/Src/sdoserv.c ****     UINT8 abort = 0;
 513              	 .loc 1 368 0
 514 0008 0023     	 movs r3,#0
 515 000a FB75     	 strb r3,[r7,#23]
 369:../SSC/Src/sdoserv.c ****     TUPLOADSDOSEGRESMBX MBXMEM * pSdoSegRes = (TUPLOADSDOSEGRESMBX MBXMEM *)pSdoInd;
 516              	 .loc 1 369 0
 517 000c 7B68     	 ldr r3,[r7,#4]
 518 000e FB60     	 str r3,[r7,#12]
 370:../SSC/Src/sdoserv.c **** 
 371:../SSC/Src/sdoserv.c ****    if ( (pSdoInd->SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle )
 519              	 .loc 1 371 0
 520 0010 7B68     	 ldr r3,[r7,#4]
 521 0012 1B7A     	 ldrb r3,[r3,#8]
 522 0014 03F01003 	 and r3,r3,#16
 523 0018 4C4A     	 ldr r2,.L37
 524 001a 1278     	 ldrb r2,[r2]
 525 001c 9342     	 cmp r3,r2
 526 001e 02D1     	 bne .L27
 372:../SSC/Src/sdoserv.c ****     {
 373:../SSC/Src/sdoserv.c ****         /* toggle bit has not toggled... */
 374:../SSC/Src/sdoserv.c ****         abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
 527              	 .loc 1 374 0
 528 0020 0123     	 movs r3,#1
 529 0022 FB75     	 strb r3,[r7,#23]
 530 0024 8CE0     	 b .L28
 531              	.L27:
 532              	.LBB4:
 375:../SSC/Src/sdoserv.c ****     }
 376:../SSC/Src/sdoserv.c ****     else
 377:../SSC/Src/sdoserv.c ****     {
 378:../SSC/Src/sdoserv.c ****         /* maxData contains the maximum data to be sent with a SDO-Upload Segment response */
 379:../SSC/Src/sdoserv.c ****          
 380:../SSC/Src/sdoserv.c ****         UINT32 size = 0;
 533              	 .loc 1 380 0
 534 0026 0023     	 movs r3,#0
 535 0028 3B61     	 str r3,[r7,#16]
 381:../SSC/Src/sdoserv.c ****         UINT16 maxData;
 382:../SSC/Src/sdoserv.c ****         {
 383:../SSC/Src/sdoserv.c ****             maxData =    u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
 536              	 .loc 1 383 0
 537 002a 494B     	 ldr r3,.L37+4
 538 002c 1B88     	 ldrh r3,[r3]
 539 002e 093B     	 subs r3,r3,#9
 540 0030 7B81     	 strh r3,[r7,#10]
 384:../SSC/Src/sdoserv.c ****         }
 385:../SSC/Src/sdoserv.c **** 
 386:../SSC/Src/sdoserv.c ****         /* the new toggle bit is stored in bSdoSegLastToggle */
 387:../SSC/Src/sdoserv.c ****         bSdoSegLastToggle = pSdoInd->SegHeader & SEGHEADER_TOGGLE;
 541              	 .loc 1 387 0
 542 0032 7B68     	 ldr r3,[r7,#4]
 543 0034 1B7A     	 ldrb r3,[r3,#8]
 544 0036 03F01003 	 and r3,r3,#16
 545 003a DAB2     	 uxtb r2,r3
 546 003c 434B     	 ldr r3,.L37
 547 003e 1A70     	 strb r2,[r3]
 388:../SSC/Src/sdoserv.c **** 
 389:../SSC/Src/sdoserv.c ****         if ( nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData) )
 548              	 .loc 1 389 0
 549 0040 7A89     	 ldrh r2,[r7,#10]
 550 0042 444B     	 ldr r3,.L37+8
 551 0044 1B68     	 ldr r3,[r3]
 552 0046 1A44     	 add r2,r2,r3
 553 0048 434B     	 ldr r3,.L37+12
 554 004a 1B68     	 ldr r3,[r3]
 555 004c 9A42     	 cmp r2,r3
 556 004e 09D9     	 bls .L29
 390:../SSC/Src/sdoserv.c ****         {
 391:../SSC/Src/sdoserv.c ****             /* the remaining data can be send with one SDO Upload Segment response,
 392:../SSC/Src/sdoserv.c ****                size contains the data to be copied */
 393:../SSC/Src/sdoserv.c ****             size = nSdoSegCompleteSize - nSdoSegBytesToHandle;
 557              	 .loc 1 393 0
 558 0050 414B     	 ldr r3,.L37+12
 559 0052 1A68     	 ldr r2,[r3]
 560 0054 3F4B     	 ldr r3,.L37+8
 561 0056 1B68     	 ldr r3,[r3]
 562 0058 D31A     	 subs r3,r2,r3
 563 005a 3B61     	 str r3,[r7,#16]
 394:../SSC/Src/sdoserv.c ****             bSdoSegFollows = FALSE;
 564              	 .loc 1 394 0
 565 005c 3F4B     	 ldr r3,.L37+16
 566 005e 0022     	 movs r2,#0
 567 0060 1A70     	 strb r2,[r3]
 568 0062 04E0     	 b .L30
 569              	.L29:
 395:../SSC/Src/sdoserv.c ****         }
 396:../SSC/Src/sdoserv.c ****         else
 397:../SSC/Src/sdoserv.c ****         {
 398:../SSC/Src/sdoserv.c ****             /* more data will follow, size contains the data to be copied */
 399:../SSC/Src/sdoserv.c ****             size = maxData;
 570              	 .loc 1 399 0
 571 0064 7B89     	 ldrh r3,[r7,#10]
 572 0066 3B61     	 str r3,[r7,#16]
 400:../SSC/Src/sdoserv.c ****             bSdoSegFollows = TRUE;
 573              	 .loc 1 400 0
 574 0068 3C4B     	 ldr r3,.L37+16
 575 006a 0122     	 movs r2,#1
 576 006c 1A70     	 strb r2,[r3]
 577              	.L30:
 401:../SSC/Src/sdoserv.c ****         }
 402:../SSC/Src/sdoserv.c **** 
 403:../SSC/Src/sdoserv.c ****         /* copy the object data in the SDO Upload segment response */
 404:../SSC/Src/sdoserv.c ****         MBXMEMCPY( pSdoSegRes->SdoHeader.Data, &(((UINT8*)pSdoSegData)[nSdoSegBytesToHandle]), size
 578              	 .loc 1 404 0
 579 006e FB68     	 ldr r3,[r7,#12]
 580 0070 03F10901 	 add r1,r3,#9
 581 0074 3A4B     	 ldr r3,.L37+20
 582 0076 1A68     	 ldr r2,[r3]
 583 0078 364B     	 ldr r3,.L37+8
 584 007a 1B68     	 ldr r3,[r3]
 585 007c 1344     	 add r3,r3,r2
 586 007e 0846     	 mov r0,r1
 587 0080 1946     	 mov r1,r3
 588 0082 3A69     	 ldr r2,[r7,#16]
 589 0084 FFF7FEFF 	 bl memcpy
 405:../SSC/Src/sdoserv.c ****         
 406:../SSC/Src/sdoserv.c ****         /* the SDO Upload Segment header depends if there is still data to be sent */
 407:../SSC/Src/sdoserv.c ****         pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 590              	 .loc 1 407 0
 591 0088 FB68     	 ldr r3,[r7,#12]
 592 008a DB88     	 ldrh r3,[r3,#6]
 593 008c C3F30B03 	 ubfx r3,r3,#0,#12
 594 0090 9AB2     	 uxth r2,r3
 595 0092 FB68     	 ldr r3,[r7,#12]
 596 0094 DA80     	 strh r2,[r3,#6]
 408:../SSC/Src/sdoserv.c ****         pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
 597              	 .loc 1 408 0
 598 0096 FB68     	 ldr r3,[r7,#12]
 599 0098 DB88     	 ldrh r3,[r3,#6]
 600 009a 43F44053 	 orr r3,r3,#12288
 601 009e 9AB2     	 uxth r2,r3
 602 00a0 FB68     	 ldr r3,[r7,#12]
 603 00a2 DA80     	 strh r2,[r3,#6]
 409:../SSC/Src/sdoserv.c **** 
 410:../SSC/Src/sdoserv.c ****         /*Clear SDO header*/
 411:../SSC/Src/sdoserv.c ****         pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
 604              	 .loc 1 411 0
 605 00a4 FB68     	 ldr r3,[r7,#12]
 606 00a6 0022     	 movs r2,#0
 607 00a8 1A72     	 strb r2,[r3,#8]
 412:../SSC/Src/sdoserv.c ****         if (bSdoSegFollows)
 608              	 .loc 1 412 0
 609 00aa 2C4B     	 ldr r3,.L37+16
 610 00ac 1B78     	 ldrb r3,[r3]
 611 00ae 002B     	 cmp r3,#0
 612 00b0 08D0     	 beq .L31
 413:../SSC/Src/sdoserv.c ****             pSdoSegRes->SdoHeader.SegHeader        |= SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastTogg
 613              	 .loc 1 413 0
 614 00b2 FB68     	 ldr r3,[r7,#12]
 615 00b4 1A7A     	 ldrb r2,[r3,#8]
 616 00b6 254B     	 ldr r3,.L37
 617 00b8 1B78     	 ldrb r3,[r3]
 618 00ba 1343     	 orrs r3,r3,r2
 619 00bc DAB2     	 uxtb r2,r3
 620 00be FB68     	 ldr r3,[r7,#12]
 621 00c0 1A72     	 strb r2,[r3,#8]
 622 00c2 0AE0     	 b .L32
 623              	.L31:
 414:../SSC/Src/sdoserv.c ****         else
 415:../SSC/Src/sdoserv.c ****             pSdoSegRes->SdoHeader.SegHeader        |= SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastTogg
 624              	 .loc 1 415 0
 625 00c4 FB68     	 ldr r3,[r7,#12]
 626 00c6 1A7A     	 ldrb r2,[r3,#8]
 627 00c8 204B     	 ldr r3,.L37
 628 00ca 1B78     	 ldrb r3,[r3]
 629 00cc 1343     	 orrs r3,r3,r2
 630 00ce DBB2     	 uxtb r3,r3
 631 00d0 43F00103 	 orr r3,r3,#1
 632 00d4 DAB2     	 uxtb r2,r3
 633 00d6 FB68     	 ldr r3,[r7,#12]
 634 00d8 1A72     	 strb r2,[r3,#8]
 635              	.L32:
 416:../SSC/Src/sdoserv.c **** 
 417:../SSC/Src/sdoserv.c ****         // operate CAN specific flag segDataSize:
 418:../SSC/Src/sdoserv.c ****         /* HBu 06.02.06: the sizes were wrong */
 419:../SSC/Src/sdoserv.c ****         if ( size < MIN_SEGMENTED_DATA )
 636              	 .loc 1 419 0
 637 00da 3B69     	 ldr r3,[r7,#16]
 638 00dc 062B     	 cmp r3,#6
 639 00de 10D8     	 bhi .L33
 420:../SSC/Src/sdoserv.c ****         {
 421:../SSC/Src/sdoserv.c ****             // at least    MIN_SEGMENTED_DATA bytes have to be send:
 422:../SSC/Src/sdoserv.c ****             pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
 640              	 .loc 1 422 0
 641 00e0 FB68     	 ldr r3,[r7,#12]
 642 00e2 0A22     	 movs r2,#10
 643 00e4 1A80     	 strh r2,[r3]
 423:../SSC/Src/sdoserv.c ****             pSdoSegRes->SdoHeader.SegHeader    |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEG
 644              	 .loc 1 423 0
 645 00e6 FB68     	 ldr r3,[r7,#12]
 646 00e8 1A7A     	 ldrb r2,[r3,#8]
 647 00ea 3B69     	 ldr r3,[r7,#16]
 648 00ec DBB2     	 uxtb r3,r3
 649 00ee C3F10703 	 rsb r3,r3,#7
 650 00f2 DBB2     	 uxtb r3,r3
 651 00f4 5B00     	 lsls r3,r3,#1
 652 00f6 DBB2     	 uxtb r3,r3
 653 00f8 1343     	 orrs r3,r3,r2
 654 00fa DAB2     	 uxtb r2,r3
 655 00fc FB68     	 ldr r3,[r7,#12]
 656 00fe 1A72     	 strb r2,[r3,#8]
 657 0100 05E0     	 b .L34
 658              	.L33:
 424:../SSC/Src/sdoserv.c ****         }
 425:../SSC/Src/sdoserv.c ****         else
 426:../SSC/Src/sdoserv.c ****         {
 427:../SSC/Src/sdoserv.c ****             pSdoSegRes->MbxHeader.Length         = ((UINT16) size) + SEGMENT_NORM_HEADER_SIZE;
 659              	 .loc 1 427 0
 660 0102 3B69     	 ldr r3,[r7,#16]
 661 0104 9BB2     	 uxth r3,r3
 662 0106 0333     	 adds r3,r3,#3
 663 0108 9AB2     	 uxth r2,r3
 664 010a FB68     	 ldr r3,[r7,#12]
 665 010c 1A80     	 strh r2,[r3]
 666              	.L34:
 428:../SSC/Src/sdoserv.c ****         }
 429:../SSC/Src/sdoserv.c **** 
 430:../SSC/Src/sdoserv.c ****         if ( bSdoSegFollows == TRUE )
 667              	 .loc 1 430 0
 668 010e 134B     	 ldr r3,.L37+16
 669 0110 1B78     	 ldrb r3,[r3]
 670 0112 012B     	 cmp r3,#1
 671 0114 06D1     	 bne .L35
 431:../SSC/Src/sdoserv.c ****             // updating the value of send bytes:
 432:../SSC/Src/sdoserv.c ****             nSdoSegBytesToHandle += size;
 672              	 .loc 1 432 0
 673 0116 0F4B     	 ldr r3,.L37+8
 674 0118 1A68     	 ldr r2,[r3]
 675 011a 3B69     	 ldr r3,[r7,#16]
 676 011c 1344     	 add r3,r3,r2
 677 011e 0D4A     	 ldr r2,.L37+8
 678 0120 1360     	 str r3,[r2]
 679 0122 0DE0     	 b .L28
 680              	.L35:
 433:../SSC/Src/sdoserv.c ****         else
 434:../SSC/Src/sdoserv.c ****         {
 435:../SSC/Src/sdoserv.c ****             FREEMEM( (UINT16 VARMEM *) pSdoSegData );
 681              	 .loc 1 435 0
 682 0124 0E4B     	 ldr r3,.L37+20
 683 0126 1B68     	 ldr r3,[r3]
 684 0128 1846     	 mov r0,r3
 685 012a FFF7FEFF 	 bl free
 436:../SSC/Src/sdoserv.c ****             pSdoSegData = NULL;
 686              	 .loc 1 436 0
 687 012e 0C4B     	 ldr r3,.L37+20
 688 0130 0022     	 movs r2,#0
 689 0132 1A60     	 str r2,[r3]
 437:../SSC/Src/sdoserv.c ****             nSdoSegBytesToHandle = 0;
 690              	 .loc 1 437 0
 691 0134 074B     	 ldr r3,.L37+8
 692 0136 0022     	 movs r2,#0
 693 0138 1A60     	 str r2,[r3]
 438:../SSC/Src/sdoserv.c ****             nSdoSegService    = 0;
 694              	 .loc 1 438 0
 695 013a 0A4B     	 ldr r3,.L37+24
 696 013c 0022     	 movs r2,#0
 697 013e 1A70     	 strb r2,[r3]
 698              	.L28:
 699              	.LBE4:
 439:../SSC/Src/sdoserv.c ****         }
 440:../SSC/Src/sdoserv.c ****     }
 441:../SSC/Src/sdoserv.c **** 
 442:../SSC/Src/sdoserv.c ****     return abort;
 700              	 .loc 1 442 0
 701 0140 FB7D     	 ldrb r3,[r7,#23]
 443:../SSC/Src/sdoserv.c **** }
 702              	 .loc 1 443 0
 703 0142 1846     	 mov r0,r3
 704 0144 1837     	 adds r7,r7,#24
 705              	.LCFI8:
 706              	 .cfi_def_cfa_offset 8
 707 0146 BD46     	 mov sp,r7
 708              	.LCFI9:
 709              	 .cfi_def_cfa_register 13
 710              	 
 711 0148 80BD     	 pop {r7,pc}
 712              	.L38:
 713 014a 00BF     	 .align 2
 714              	.L37:
 715 014c 00000000 	 .word bSdoSegLastToggle
 716 0150 00000000 	 .word u16SendMbxSize
 717 0154 00000000 	 .word nSdoSegBytesToHandle
 718 0158 00000000 	 .word nSdoSegCompleteSize
 719 015c 00000000 	 .word bSdoSegFollows
 720 0160 00000000 	 .word pSdoSegData
 721 0164 00000000 	 .word nSdoSegService
 722              	 .cfi_endproc
 723              	.LFE173:
 725              	 .section .text.SdoRes,"ax",%progbits
 726              	 .align 2
 727              	 .global SdoRes
 728              	 .thumb
 729              	 .thumb_func
 731              	SdoRes:
 732              	.LFB174:
 444:../SSC/Src/sdoserv.c **** 
 445:../SSC/Src/sdoserv.c **** 
 446:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 447:../SSC/Src/sdoserv.c **** /**
 448:../SSC/Src/sdoserv.c ****  \param    abort                 Result of the SDO access
 449:../SSC/Src/sdoserv.c ****  \param    command		         SDO command index 
 450:../SSC/Src/sdoserv.c ****  \param    completeAccess        Indicates if complete access was requested
 451:../SSC/Src/sdoserv.c ****  \param    dataSize              Available data buffer in the response
 452:../SSC/Src/sdoserv.c ****  \param    objLength             Complete size of the object
 453:../SSC/Src/sdoserv.c ****  \param     pSdoRes                Pointer to the mailbox buffer
 454:../SSC/Src/sdoserv.c **** 
 455:../SSC/Src/sdoserv.c ****  \brief    This function is called when a SDO response shall be sent
 456:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 457:../SSC/Src/sdoserv.c **** 
 458:../SSC/Src/sdoserv.c **** void SdoRes(UINT8 abort, UINT8 command, UINT8 completeAccess, UINT16 dataSize, UINT32 objLength, TI
 459:../SSC/Src/sdoserv.c **** {
 733              	 .loc 1 459 0
 734              	 .cfi_startproc
 735              	 
 736              	 
 737 0000 90B5     	 push {r4,r7,lr}
 738              	.LCFI10:
 739              	 .cfi_def_cfa_offset 12
 740              	 .cfi_offset 4,-12
 741              	 .cfi_offset 7,-8
 742              	 .cfi_offset 14,-4
 743 0002 83B0     	 sub sp,sp,#12
 744              	.LCFI11:
 745              	 .cfi_def_cfa_offset 24
 746 0004 00AF     	 add r7,sp,#0
 747              	.LCFI12:
 748              	 .cfi_def_cfa_register 7
 749 0006 0446     	 mov r4,r0
 750 0008 0846     	 mov r0,r1
 751 000a 1146     	 mov r1,r2
 752 000c 1A46     	 mov r2,r3
 753 000e 2346     	 mov r3,r4
 754 0010 FB71     	 strb r3,[r7,#7]
 755 0012 0346     	 mov r3,r0
 756 0014 BB71     	 strb r3,[r7,#6]
 757 0016 0B46     	 mov r3,r1
 758 0018 7B71     	 strb r3,[r7,#5]
 759 001a 1346     	 mov r3,r2
 760 001c 7B80     	 strh r3,[r7,#2]
 460:../SSC/Src/sdoserv.c ****     /* for an upload segment response the toggle bit was overwritten */
 461:../SSC/Src/sdoserv.c ****     if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
 761              	 .loc 1 461 0
 762 001e BB79     	 ldrb r3,[r7,#6]
 763 0020 602B     	 cmp r3,#96
 764 0022 05D0     	 beq .L40
 765              	 .loc 1 461 0 is_stmt 0 discriminator 1
 766 0024 BB79     	 ldrb r3,[r7,#6]
 767 0026 002B     	 cmp r3,#0
 768 0028 02D0     	 beq .L40
 462:../SSC/Src/sdoserv.c ****     {
 463:../SSC/Src/sdoserv.c ****         pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] = 0;
 769              	 .loc 1 463 0 is_stmt 1
 770 002a FB69     	 ldr r3,[r7,#28]
 771 002c 0022     	 movs r2,#0
 772 002e 1A72     	 strb r2,[r3,#8]
 773              	.L40:
 464:../SSC/Src/sdoserv.c ****     }
 465:../SSC/Src/sdoserv.c ****     if ( abort == 0 )
 774              	 .loc 1 465 0
 775 0030 FB79     	 ldrb r3,[r7,#7]
 776 0032 002B     	 cmp r3,#0
 777 0034 6CD1     	 bne .L41
 466:../SSC/Src/sdoserv.c ****     {
 467:../SSC/Src/sdoserv.c ****         /* SDO-Download or SDO-Upload was successful, generate the SDO- and CoE-Header */
 468:../SSC/Src/sdoserv.c ****         pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 778              	 .loc 1 468 0
 779 0036 FB69     	 ldr r3,[r7,#28]
 780 0038 DB88     	 ldrh r3,[r3,#6]
 781 003a C3F30B03 	 ubfx r3,r3,#0,#12
 782 003e 9AB2     	 uxth r2,r3
 783 0040 FB69     	 ldr r3,[r7,#28]
 784 0042 DA80     	 strh r2,[r3,#6]
 469:../SSC/Src/sdoserv.c ****         pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
 785              	 .loc 1 469 0
 786 0044 FB69     	 ldr r3,[r7,#28]
 787 0046 DB88     	 ldrh r3,[r3,#6]
 788 0048 43F44053 	 orr r3,r3,#12288
 789 004c 9AB2     	 uxth r2,r3
 790 004e FB69     	 ldr r3,[r7,#28]
 791 0050 DA80     	 strh r2,[r3,#6]
 470:../SSC/Src/sdoserv.c ****         if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 792              	 .loc 1 470 0
 793 0052 BB79     	 ldrb r3,[r7,#6]
 794 0054 402B     	 cmp r3,#64
 795 0056 3FD1     	 bne .L42
 471:../SSC/Src/sdoserv.c ****         {
 472:../SSC/Src/sdoserv.c ****             // HBu 06.02.06: Complete Access Bit in the SDO-Upload-Response too */
 473:../SSC/Src/sdoserv.c ****             if ( (objLength <= 4) && (objLength > 0) )
 796              	 .loc 1 473 0
 797 0058 BB69     	 ldr r3,[r7,#24]
 798 005a 042B     	 cmp r3,#4
 799 005c 18D8     	 bhi .L43
 800              	 .loc 1 473 0 is_stmt 0 discriminator 1
 801 005e BB69     	 ldr r3,[r7,#24]
 802 0060 002B     	 cmp r3,#0
 803 0062 15D0     	 beq .L43
 474:../SSC/Src/sdoserv.c ****             {
 475:../SSC/Src/sdoserv.c ****                 /* Expedited Upload Response */
 476:../SSC/Src/sdoserv.c ****                 pSdoRes->MbxHeader.Length             =         EXPEDITED_FRAME_SIZE;
 804              	 .loc 1 476 0 is_stmt 1
 805 0064 FB69     	 ldr r3,[r7,#28]
 806 0066 0A22     	 movs r2,#10
 807 0068 1A80     	 strh r2,[r3]
 477:../SSC/Src/sdoserv.c ****                 pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |=     SDOHEADER_SIZEINDICATOR  
 808              	 .loc 1 477 0
 809 006a FB69     	 ldr r3,[r7,#28]
 810 006c 1A7A     	 ldrb r2,[r3,#8]
 478:../SSC/Src/sdoserv.c ****                                                                                         SDOHEADER_T
 479:../SSC/Src/sdoserv.c ****                                                                                         completeAcc
 480:../SSC/Src/sdoserv.c ****                                                                                         ((MAX_EXPED
 811              	 .loc 1 480 0
 812 006e BB69     	 ldr r3,[r7,#24]
 813 0070 DBB2     	 uxtb r3,r3
 814 0072 C3F10403 	 rsb r3,r3,#4
 815 0076 9B00     	 lsls r3,r3,#2
 477:../SSC/Src/sdoserv.c ****                 pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |=     SDOHEADER_SIZEINDICATOR  
 816              	 .loc 1 477 0
 817 0078 D9B2     	 uxtb r1,r3
 818 007a 7B79     	 ldrb r3,[r7,#5]
 819 007c 0B43     	 orrs r3,r3,r1
 820 007e DBB2     	 uxtb r3,r3
 821 0080 1343     	 orrs r3,r3,r2
 822 0082 DBB2     	 uxtb r3,r3
 823 0084 43F04303 	 orr r3,r3,#67
 824 0088 DAB2     	 uxtb r2,r3
 825 008a FB69     	 ldr r3,[r7,#28]
 826 008c 1A72     	 strb r2,[r3,#8]
 827 008e 59E0     	 b .L49
 828              	.L43:
 481:../SSC/Src/sdoserv.c ****                                                                                         SDOSERVICE_
 482:../SSC/Src/sdoserv.c ****             }
 483:../SSC/Src/sdoserv.c ****             else
 484:../SSC/Src/sdoserv.c ****             {
 485:../SSC/Src/sdoserv.c ****                 /* Normal or Segmented Upload Response */
 486:../SSC/Src/sdoserv.c ****                 if (dataSize <  objLength)
 829              	 .loc 1 486 0
 830 0090 7A88     	 ldrh r2,[r7,#2]
 831 0092 BB69     	 ldr r3,[r7,#24]
 832 0094 9A42     	 cmp r2,r3
 833 0096 05D2     	 bcs .L45
 487:../SSC/Src/sdoserv.c ****                 {
 488:../SSC/Src/sdoserv.c ****                     pSdoRes->MbxHeader.Length         =         UPLOAD_NORM_RES_SIZE+dataSize;
 834              	 .loc 1 488 0
 835 0098 7B88     	 ldrh r3,[r7,#2]
 836 009a 0A33     	 adds r3,r3,#10
 837 009c 9AB2     	 uxth r2,r3
 838 009e FB69     	 ldr r3,[r7,#28]
 839 00a0 1A80     	 strh r2,[r3]
 840 00a2 05E0     	 b .L46
 841              	.L45:
 489:../SSC/Src/sdoserv.c ****                 }
 490:../SSC/Src/sdoserv.c ****                 else
 491:../SSC/Src/sdoserv.c ****                 {
 492:../SSC/Src/sdoserv.c ****                     pSdoRes->MbxHeader.Length         =         UPLOAD_NORM_RES_SIZE+((UINT16)objLe
 842              	 .loc 1 492 0
 843 00a4 BB69     	 ldr r3,[r7,#24]
 844 00a6 9BB2     	 uxth r3,r3
 845 00a8 0A33     	 adds r3,r3,#10
 846 00aa 9AB2     	 uxth r2,r3
 847 00ac FB69     	 ldr r3,[r7,#28]
 848 00ae 1A80     	 strh r2,[r3]
 849              	.L46:
 493:../SSC/Src/sdoserv.c ****                 }
 494:../SSC/Src/sdoserv.c ****                    ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[0] = SWAPWORD((UINT1
 850              	 .loc 1 494 0
 851 00b0 BB69     	 ldr r3,[r7,#24]
 852 00b2 9AB2     	 uxth r2,r3
 853 00b4 FB69     	 ldr r3,[r7,#28]
 854 00b6 9A81     	 strh r2,[r3,#12]
 495:../SSC/Src/sdoserv.c ****                    ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT1
 855              	 .loc 1 495 0
 856 00b8 BB69     	 ldr r3,[r7,#24]
 857 00ba 1B0C     	 lsrs r3,r3,#16
 858 00bc 9AB2     	 uxth r2,r3
 859 00be FB69     	 ldr r3,[r7,#28]
 860 00c0 DA81     	 strh r2,[r3,#14]
 496:../SSC/Src/sdoserv.c ****                 pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |=     SDOHEADER_SIZEINDICATOR  
 861              	 .loc 1 496 0
 862 00c2 FB69     	 ldr r3,[r7,#28]
 863 00c4 1A7A     	 ldrb r2,[r3,#8]
 864 00c6 7B79     	 ldrb r3,[r7,#5]
 865 00c8 1343     	 orrs r3,r3,r2
 866 00ca DBB2     	 uxtb r3,r3
 867 00cc 43F04103 	 orr r3,r3,#65
 868 00d0 DAB2     	 uxtb r2,r3
 869 00d2 FB69     	 ldr r3,[r7,#28]
 870 00d4 1A72     	 strb r2,[r3,#8]
 871 00d6 35E0     	 b .L49
 872              	.L42:
 497:../SSC/Src/sdoserv.c ****                                                                                         completeAcc
 498:../SSC/Src/sdoserv.c ****                                                                                         SDOSERVICE_
 499:../SSC/Src/sdoserv.c ****             }
 500:../SSC/Src/sdoserv.c ****         }
 501:../SSC/Src/sdoserv.c ****         /* for a segmented response the command was wrong in the response */
 502:../SSC/Src/sdoserv.c ****         else if ( command == SDOSERVICE_DOWNLOADSEGMENTREQ )
 873              	 .loc 1 502 0
 874 00d8 BB79     	 ldrb r3,[r7,#6]
 875 00da 002B     	 cmp r3,#0
 876 00dc 0AD1     	 bne .L48
 503:../SSC/Src/sdoserv.c ****         {
 504:../SSC/Src/sdoserv.c ****             /* Download segmented response */
 505:../SSC/Src/sdoserv.c ****             pSdoRes->MbxHeader.Length         = DOWNLOAD_NORM_RES_SIZE;
 877              	 .loc 1 505 0
 878 00de FB69     	 ldr r3,[r7,#28]
 879 00e0 0A22     	 movs r2,#10
 880 00e2 1A80     	 strh r2,[r3]
 506:../SSC/Src/sdoserv.c ****             pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= SDOSERVICE_DOWNLOADSEGMENTRES;
 881              	 .loc 1 506 0
 882 00e4 FB69     	 ldr r3,[r7,#28]
 883 00e6 1B7A     	 ldrb r3,[r3,#8]
 884 00e8 43F02003 	 orr r3,r3,#32
 885 00ec DAB2     	 uxtb r2,r3
 886 00ee FB69     	 ldr r3,[r7,#28]
 887 00f0 1A72     	 strb r2,[r3,#8]
 888 00f2 27E0     	 b .L49
 889              	.L48:
 507:../SSC/Src/sdoserv.c ****       }
 508:../SSC/Src/sdoserv.c ****         else if ( command != SDOSERVICE_UPLOADSEGMENTREQ )
 890              	 .loc 1 508 0
 891 00f4 BB79     	 ldrb r3,[r7,#6]
 892 00f6 602B     	 cmp r3,#96
 893 00f8 24D0     	 beq .L49
 509:../SSC/Src/sdoserv.c ****         {
 510:../SSC/Src/sdoserv.c ****             /* Download response */
 511:../SSC/Src/sdoserv.c ****             pSdoRes->MbxHeader.Length         = DOWNLOAD_NORM_RES_SIZE;
 894              	 .loc 1 511 0
 895 00fa FB69     	 ldr r3,[r7,#28]
 896 00fc 0A22     	 movs r2,#10
 897 00fe 1A80     	 strh r2,[r3]
 512:../SSC/Src/sdoserv.c ****             pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= SDOSERVICE_INITIATEDOWNLOADRES;
 898              	 .loc 1 512 0
 899 0100 FB69     	 ldr r3,[r7,#28]
 900 0102 1B7A     	 ldrb r3,[r3,#8]
 901 0104 43F06003 	 orr r3,r3,#96
 902 0108 DAB2     	 uxtb r2,r3
 903 010a FB69     	 ldr r3,[r7,#28]
 904 010c 1A72     	 strb r2,[r3,#8]
 905 010e 19E0     	 b .L49
 906              	.L41:
 513:../SSC/Src/sdoserv.c ****         }
 514:../SSC/Src/sdoserv.c ****     }
 515:../SSC/Src/sdoserv.c ****     else
 516:../SSC/Src/sdoserv.c ****     {
 517:../SSC/Src/sdoserv.c ****         /* generate a SDO-Abort-Request */
 518:../SSC/Src/sdoserv.c ****         pSdoRes->MbxHeader.Length         = ABORT_NORM_RES_SIZE;
 907              	 .loc 1 518 0
 908 0110 FB69     	 ldr r3,[r7,#28]
 909 0112 0A22     	 movs r2,#10
 910 0114 1A80     	 strh r2,[r3]
 519:../SSC/Src/sdoserv.c ****         pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 911              	 .loc 1 519 0
 912 0116 FB69     	 ldr r3,[r7,#28]
 913 0118 DB88     	 ldrh r3,[r3,#6]
 914 011a C3F30B03 	 ubfx r3,r3,#0,#12
 915 011e 9AB2     	 uxth r2,r3
 916 0120 FB69     	 ldr r3,[r7,#28]
 917 0122 DA80     	 strh r2,[r3,#6]
 520:../SSC/Src/sdoserv.c ****         pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDOREQUEST) << COEHEADER_COESERVICESHIFT;
 918              	 .loc 1 520 0
 919 0124 FB69     	 ldr r3,[r7,#28]
 920 0126 DB88     	 ldrh r3,[r3,#6]
 921 0128 43F40053 	 orr r3,r3,#8192
 922 012c 9AB2     	 uxth r2,r3
 923 012e FB69     	 ldr r3,[r7,#28]
 924 0130 DA80     	 strh r2,[r3,#6]
 521:../SSC/Src/sdoserv.c ****         pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    = SDOSERVICE_ABORTTRANSFER;
 925              	 .loc 1 521 0
 926 0132 FB69     	 ldr r3,[r7,#28]
 927 0134 8022     	 movs r2,#128
 928 0136 1A72     	 strb r2,[r3,#8]
 522:../SSC/Src/sdoserv.c ****         ((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
 929              	 .loc 1 522 0
 930 0138 FB79     	 ldrb r3,[r7,#7]
 931 013a 094A     	 ldr r2,.L51
 932 013c 52F82320 	 ldr r2,[r2,r3,lsl#2]
 933 0140 FB69     	 ldr r3,[r7,#28]
 934 0142 DA60     	 str r2,[r3,#12]
 935              	.L49:
 523:../SSC/Src/sdoserv.c ****     }
 524:../SSC/Src/sdoserv.c **** 
 525:../SSC/Src/sdoserv.c ****     // HBu 02.05.06: if the CoE-response could not be sent because the
 526:../SSC/Src/sdoserv.c ****     //               send mailbox is full it should be stored
 527:../SSC/Src/sdoserv.c ****     if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoRes, COE_SERVICE) != 0)
 936              	 .loc 1 527 0
 937 0144 F869     	 ldr r0,[r7,#28]
 938 0146 0221     	 movs r1,#2
 939 0148 FFF7FEFF 	 bl MBX_MailboxSendReq
 940 014c 0346     	 mov r3,r0
 941 014e 002B     	 cmp r3,#0
 942 0150 02D0     	 beq .L39
 528:../SSC/Src/sdoserv.c ****     {
 529:../SSC/Src/sdoserv.c ****         /* we store the CoE mailbox service to send it later (in COE_ContinueInd) when the mailbox 
 530:../SSC/Src/sdoserv.c ****         pCoeSendStored = (TMBX MBXMEM *) pSdoRes;
 943              	 .loc 1 530 0
 944 0152 044A     	 ldr r2,.L51+4
 945 0154 FB69     	 ldr r3,[r7,#28]
 946 0156 1360     	 str r3,[r2]
 947              	.L39:
 531:../SSC/Src/sdoserv.c ****     }
 532:../SSC/Src/sdoserv.c **** }
 948              	 .loc 1 532 0
 949 0158 0C37     	 adds r7,r7,#12
 950              	.LCFI13:
 951              	 .cfi_def_cfa_offset 12
 952 015a BD46     	 mov sp,r7
 953              	.LCFI14:
 954              	 .cfi_def_cfa_register 13
 955              	 
 956 015c 90BD     	 pop {r4,r7,pc}
 957              	.L52:
 958 015e 00BF     	 .align 2
 959              	.L51:
 960 0160 00000000 	 .word cAbortCode
 961 0164 00000000 	 .word pCoeSendStored
 962              	 .cfi_endproc
 963              	.LFE174:
 965              	 .section .text.SDOS_SdoInd,"ax",%progbits
 966              	 .align 2
 967              	 .global SDOS_SdoInd
 968              	 .thumb
 969              	 .thumb_func
 971              	SDOS_SdoInd:
 972              	.LFB175:
 533:../SSC/Src/sdoserv.c **** 
 534:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 535:../SSC/Src/sdoserv.c **** /**
 536:../SSC/Src/sdoserv.c ****  \param     pSdoInd    Pointer to the received mailbox data from the master.
 537:../SSC/Src/sdoserv.c **** 
 538:../SSC/Src/sdoserv.c ****  \return    Indicates if an error occurred while the operation ( good = 0 ).
 539:../SSC/Src/sdoserv.c **** 
 540:../SSC/Src/sdoserv.c ****  \brief    This function is called when a SDO request service
 541:../SSC/Src/sdoserv.c ****             is received from the master and calls depending from
 542:../SSC/Src/sdoserv.c ****             the command the concerning function.
 543:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 544:../SSC/Src/sdoserv.c **** 
 545:../SSC/Src/sdoserv.c **** UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
 546:../SSC/Src/sdoserv.c **** {
 973              	 .loc 1 546 0
 974              	 .cfi_startproc
 975              	 
 976              	 
 977 0000 90B5     	 push {r4,r7,lr}
 978              	.LCFI15:
 979              	 .cfi_def_cfa_offset 12
 980              	 .cfi_offset 4,-12
 981              	 .cfi_offset 7,-8
 982              	 .cfi_offset 14,-4
 983 0002 8FB0     	 sub sp,sp,#60
 984              	.LCFI16:
 985              	 .cfi_def_cfa_offset 72
 986 0004 02AF     	 add r7,sp,#8
 987              	.LCFI17:
 988              	 .cfi_def_cfa 7,64
 989 0006 7860     	 str r0,[r7,#4]
 547:../SSC/Src/sdoserv.c ****     UINT8 abort = 0;
 990              	 .loc 1 547 0
 991 0008 0023     	 movs r3,#0
 992 000a 87F82F30 	 strb r3,[r7,#47]
 548:../SSC/Src/sdoserv.c ****     UINT8 sdoHeader = pSdoInd->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMANDMASK;
 993              	 .loc 1 548 0
 994 000e 7B68     	 ldr r3,[r7,#4]
 995 0010 1B7A     	 ldrb r3,[r3,#8]
 996 0012 BB76     	 strb r3,[r7,#26]
 549:../SSC/Src/sdoserv.c ****     /* the SDO-command is in bit 5-7 of the first SDO-Byte */
 550:../SSC/Src/sdoserv.c ****     UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
 997              	 .loc 1 550 0
 998 0014 BB7E     	 ldrb r3,[r7,#26]
 999 0016 23F01F03 	 bic r3,r3,#31
 1000 001a 7B76     	 strb r3,[r7,#25]
 551:../SSC/Src/sdoserv.c ****     /* mbxSize contains the size of the mailbox (CoE-Header (2 Bytes) + SDO-Header (8 Bytes) + SDO-
 552:../SSC/Src/sdoserv.c ****     UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
 1001              	 .loc 1 552 0
 1002 001c 7B68     	 ldr r3,[r7,#4]
 1003 001e 1B88     	 ldrh r3,[r3]
 1004 0020 FB82     	 strh r3,[r7,#22]
 553:../SSC/Src/sdoserv.c ****     UINT16 index;
 554:../SSC/Src/sdoserv.c ****     UINT8 subindex;
 555:../SSC/Src/sdoserv.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry;
 556:../SSC/Src/sdoserv.c ****     /* this variable contains the information, if all entries of an object will be read (bCompleteA
 557:../SSC/Src/sdoserv.c ****     UINT8 bCompleteAccess = 0;
 1005              	 .loc 1 557 0
 1006 0022 0023     	 movs r3,#0
 1007 0024 87F82E30 	 strb r3,[r7,#46]
 558:../SSC/Src/sdoserv.c ****     UINT32 objLength = 0;
 1008              	 .loc 1 558 0
 1009 0028 0023     	 movs r3,#0
 1010 002a BB62     	 str r3,[r7,#40]
 559:../SSC/Src/sdoserv.c ****     UINT32 dataSize = 0;
 1011              	 .loc 1 559 0
 1012 002c 0023     	 movs r3,#0
 1013 002e 7B62     	 str r3,[r7,#36]
 560:../SSC/Src/sdoserv.c **** 
 561:../SSC/Src/sdoserv.c ****     if ( bSdoInWork )
 1014              	 .loc 1 561 0
 1015 0030 994B     	 ldr r3,.L94
 1016 0032 1B78     	 ldrb r3,[r3]
 1017 0034 002B     	 cmp r3,#0
 1018 0036 01D0     	 beq .L54
 562:../SSC/Src/sdoserv.c ****     {
 563:../SSC/Src/sdoserv.c ****         /* the last SDO is still in work */
 564:../SSC/Src/sdoserv.c ****         return MBXERR_SERVICEINWORK;
 1019              	 .loc 1 564 0
 1020 0038 0923     	 movs r3,#9
 1021 003a 75E2     	 b .L55
 1022              	.L54:
 565:../SSC/Src/sdoserv.c ****     }
 566:../SSC/Src/sdoserv.c **** 
 567:../SSC/Src/sdoserv.c **** 
 568:../SSC/Src/sdoserv.c ****     switch (command)
 1023              	 .loc 1 568 0
 1024 003c 7B7E     	 ldrb r3,[r7,#25]
 1025 003e 202B     	 cmp r3,#32
 1026 0040 0BD0     	 beq .L57
 1027 0042 202B     	 cmp r3,#32
 1028 0044 03DC     	 bgt .L58
 1029 0046 002B     	 cmp r3,#0
 1030 0048 00F03B82 	 beq .L59
 1031 004c 53E2     	 b .L56
 1032              	.L58:
 1033 004e 402B     	 cmp r3,#64
 1034 0050 03D0     	 beq .L57
 1035 0052 602B     	 cmp r3,#96
 1036 0054 00F03582 	 beq .L59
 1037 0058 4DE2     	 b .L56
 1038              	.L57:
 569:../SSC/Src/sdoserv.c ****     {
 570:../SSC/Src/sdoserv.c ****     case SDOSERVICE_INITIATEDOWNLOADREQ:
 571:../SSC/Src/sdoserv.c ****     case SDOSERVICE_INITIATEUPLOADREQ:
 572:../SSC/Src/sdoserv.c ****         /* the variable index contains the requested index of the SDO service */
 573:../SSC/Src/sdoserv.c ****         index = pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXHIOFFSET] & SDOHEADER_INDEXHIMASK;
 1039              	 .loc 1 573 0
 1040 005a 7B68     	 ldr r3,[r7,#4]
 1041 005c 9B7A     	 ldrb r3,[r3,#10]
 1042 005e BB82     	 strh r3,[r7,#20]
 574:../SSC/Src/sdoserv.c ****         index <<= 8;
 1043              	 .loc 1 574 0
 1044 0060 BB8A     	 ldrh r3,[r7,#20]
 1045 0062 1B02     	 lsls r3,r3,#8
 1046 0064 BB82     	 strh r3,[r7,#20]
 575:../SSC/Src/sdoserv.c ****         index += pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXLOOFFSET] >> SDOHEADER_INDEXLOSHIFT;
 1047              	 .loc 1 575 0
 1048 0066 7B68     	 ldr r3,[r7,#4]
 1049 0068 5B7A     	 ldrb r3,[r3,#9]
 1050 006a 9AB2     	 uxth r2,r3
 1051 006c BB8A     	 ldrh r3,[r7,#20]
 1052 006e 1344     	 add r3,r3,r2
 1053 0070 BB82     	 strh r3,[r7,#20]
 576:../SSC/Src/sdoserv.c ****         /* the variable subindex contains the requested subindex of the SDO service */
 577:../SSC/Src/sdoserv.c ****         subindex    = pSdoInd->SdoHeader.Sdo[SDOHEADER_SUBINDEXOFFSET] >> SDOHEADER_SUBINDEXSHIFT;
 1054              	 .loc 1 577 0
 1055 0072 7B68     	 ldr r3,[r7,#4]
 1056 0074 DB7A     	 ldrb r3,[r3,#11]
 1057 0076 FB74     	 strb r3,[r7,#19]
 578:../SSC/Src/sdoserv.c **** 
 579:../SSC/Src/sdoserv.c ****         /* OBJ_GetObjectHandle checks if the requested index is defined in the object dictionary */
 580:../SSC/Src/sdoserv.c ****         pObjEntry = OBJ_GetObjectHandle( index );
 1058              	 .loc 1 580 0
 1059 0078 BB8A     	 ldrh r3,[r7,#20]
 1060 007a 1846     	 mov r0,r3
 1061 007c FFF7FEFF 	 bl OBJ_GetObjectHandle
 1062 0080 F860     	 str r0,[r7,#12]
 581:../SSC/Src/sdoserv.c **** 
 582:../SSC/Src/sdoserv.c ****         if ( pObjEntry )
 1063              	 .loc 1 582 0
 1064 0082 FB68     	 ldr r3,[r7,#12]
 1065 0084 002B     	 cmp r3,#0
 1066 0086 00F01782 	 beq .L60
 1067              	.LBB5:
 583:../SSC/Src/sdoserv.c ****         {
 584:../SSC/Src/sdoserv.c ****             /* transferType contains the information if the SDO Download Request or the SDO Upload 
 585:../SSC/Src/sdoserv.c ****                can be an expedited service (SDO data length <= 4, that means the data is stored in 
 586:../SSC/Src/sdoserv.c ****                 SDO-Header completely */
 587:../SSC/Src/sdoserv.c ****             UINT8 bTransferType = 0;
 1068              	 .loc 1 587 0
 1069 008a 0023     	 movs r3,#0
 1070 008c 87F82330 	 strb r3,[r7,#35]
 588:../SSC/Src/sdoserv.c ****             /* pData is the pointer to the received (SDO-Download) or sent (SDO-Upload) SDO data in
 589:../SSC/Src/sdoserv.c ****             UINT16 MBXMEM * pData = NULL;
 1071              	 .loc 1 589 0
 1072 0090 0023     	 movs r3,#0
 1073 0092 FB61     	 str r3,[r7,#28]
 590:../SSC/Src/sdoserv.c ****             UINT8 segTransfer = 0;
 1074              	 .loc 1 590 0
 1075 0094 0023     	 movs r3,#0
 1076 0096 FB76     	 strb r3,[r7,#27]
 591:../SSC/Src/sdoserv.c **** 
 592:../SSC/Src/sdoserv.c ****             {
 593:../SSC/Src/sdoserv.c ****                 dataSize = objLength = OBJ_GetObjectLength( index, subindex, pObjEntry, (UINT8) (sd
 1077              	 .loc 1 593 0
 1078 0098 BB7E     	 ldrb r3,[r7,#26]
 1079 009a 03F01003 	 and r3,r3,#16
 1080 009e DBB2     	 uxtb r3,r3
 1081 00a0 B98A     	 ldrh r1,[r7,#20]
 1082 00a2 FA7C     	 ldrb r2,[r7,#19]
 1083 00a4 0846     	 mov r0,r1
 1084 00a6 1146     	 mov r1,r2
 1085 00a8 FA68     	 ldr r2,[r7,#12]
 1086 00aa FFF7FEFF 	 bl OBJ_GetObjectLength
 1087 00ae B862     	 str r0,[r7,#40]
 1088 00b0 BB6A     	 ldr r3,[r7,#40]
 1089 00b2 7B62     	 str r3,[r7,#36]
 594:../SSC/Src/sdoserv.c **** 
 595:../SSC/Src/sdoserv.c ****                 if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 1090              	 .loc 1 595 0
 1091 00b4 7B7E     	 ldrb r3,[r7,#25]
 1092 00b6 402B     	 cmp r3,#64
 1093 00b8 27D1     	 bne .L61
 596:../SSC/Src/sdoserv.c ****                 {
 597:../SSC/Src/sdoserv.c ****                     /* SDO Upload */
 598:../SSC/Src/sdoserv.c ****                     if ( mbxSize != EXPEDITED_FRAME_SIZE )
 1094              	 .loc 1 598 0
 1095 00ba FB8A     	 ldrh r3,[r7,#22]
 1096 00bc 0A2B     	 cmp r3,#10
 1097 00be 01D0     	 beq .L62
 599:../SSC/Src/sdoserv.c ****                         /* a SDO Upload request has always a fixed size (2 Byte CoE-Header plus 8 B
 600:../SSC/Src/sdoserv.c ****                         return MBXERR_INVALIDSIZE;
 1098              	 .loc 1 600 0
 1099 00c0 0823     	 movs r3,#8
 1100 00c2 31E2     	 b .L55
 1101              	.L62:
 601:../SSC/Src/sdoserv.c ****                     /* distinguish between expedited and normal upload response within the length o
 602:../SSC/Src/sdoserv.c ****                     if ( (objLength <= MAX_EXPEDITED_DATA) && objLength != 0 )
 1102              	 .loc 1 602 0
 1103 00c4 BB6A     	 ldr r3,[r7,#40]
 1104 00c6 042B     	 cmp r3,#4
 1105 00c8 10D8     	 bhi .L63
 1106              	 .loc 1 602 0 is_stmt 0 discriminator 1
 1107 00ca BB6A     	 ldr r3,[r7,#40]
 1108 00cc 002B     	 cmp r3,#0
 1109 00ce 0DD0     	 beq .L63
 603:../SSC/Src/sdoserv.c ****                     {
 604:../SSC/Src/sdoserv.c ****                         /* Expedited Upload */
 605:../SSC/Src/sdoserv.c ****                         bTransferType = 1;
 1110              	 .loc 1 605 0 is_stmt 1
 1111 00d0 0123     	 movs r3,#1
 1112 00d2 87F82330 	 strb r3,[r7,#35]
 606:../SSC/Src/sdoserv.c ****                         /* pData is the pointer where the object data has to be copied for the resp
 607:../SSC/Src/sdoserv.c ****                         pData = ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoInd)->Data;
 1113              	 .loc 1 607 0
 1114 00d6 7B68     	 ldr r3,[r7,#4]
 1115 00d8 0C33     	 adds r3,r3,#12
 1116 00da FB61     	 str r3,[r7,#28]
 608:../SSC/Src/sdoserv.c ****                         /* initialize the 4 data bytes of the SDO upload response because the reque
 609:../SSC/Src/sdoserv.c ****                            could be less than 4 */
 610:../SSC/Src/sdoserv.c ****                         pData[0] = 0;
 1117              	 .loc 1 610 0
 1118 00dc FB69     	 ldr r3,[r7,#28]
 1119 00de 0022     	 movs r2,#0
 1120 00e0 1A80     	 strh r2,[r3]
 611:../SSC/Src/sdoserv.c ****                         pData[1] = 0;
 1121              	 .loc 1 611 0
 1122 00e2 FB69     	 ldr r3,[r7,#28]
 1123 00e4 0233     	 adds r3,r3,#2
 1124 00e6 0022     	 movs r2,#0
 1125 00e8 1A80     	 strh r2,[r3]
 1126 00ea 13E0     	 b .L66
 1127              	.L63:
 612:../SSC/Src/sdoserv.c ****                     }
 613:../SSC/Src/sdoserv.c ****                     else
 614:../SSC/Src/sdoserv.c ****                     {
 615:../SSC/Src/sdoserv.c ****                         /* HBu 06.02.06: the variable dataSize has to be set to the available size 
 616:../SSC/Src/sdoserv.c ****                     dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
 1128              	 .loc 1 616 0
 1129 00ec 6B4B     	 ldr r3,.L94+4
 1130 00ee 1B88     	 ldrh r3,[r3]
 1131 00f0 103B     	 subs r3,r3,#16
 1132 00f2 7B62     	 str r3,[r7,#36]
 617:../SSC/Src/sdoserv.c ****                         if ( dataSize < objLength )
 1133              	 .loc 1 617 0
 1134 00f4 7A6A     	 ldr r2,[r7,#36]
 1135 00f6 BB6A     	 ldr r3,[r7,#40]
 1136 00f8 9A42     	 cmp r2,r3
 1137 00fa 02D2     	 bcs .L65
 618:../SSC/Src/sdoserv.c ****                             /* Segmented Upload */
 619:../SSC/Src/sdoserv.c ****                             segTransfer = 1;
 1138              	 .loc 1 619 0
 1139 00fc 0123     	 movs r3,#1
 1140 00fe FB76     	 strb r3,[r7,#27]
 1141 0100 08E0     	 b .L66
 1142              	.L65:
 620:../SSC/Src/sdoserv.c ****                         else
 621:../SSC/Src/sdoserv.c ****                             /* Normal Upload */
 622:../SSC/Src/sdoserv.c ****                             pData = ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data;
 1143              	 .loc 1 622 0
 1144 0102 7B68     	 ldr r3,[r7,#4]
 1145 0104 1033     	 adds r3,r3,#16
 1146 0106 FB61     	 str r3,[r7,#28]
 1147 0108 04E0     	 b .L66
 1148              	.L61:
 623:../SSC/Src/sdoserv.c ****                     }
 624:../SSC/Src/sdoserv.c ****                 }
 625:../SSC/Src/sdoserv.c ****                 else
 626:../SSC/Src/sdoserv.c ****                 {
 627:../SSC/Src/sdoserv.c ****                     /* SDO-Download: store if the request is a expedited or normal request  */
 628:../SSC/Src/sdoserv.c ****                     bTransferType = sdoHeader & SDOHEADER_TRANSFERTYPE;
 1149              	 .loc 1 628 0
 1150 010a BB7E     	 ldrb r3,[r7,#26]
 1151 010c 03F00203 	 and r3,r3,#2
 1152 0110 87F82330 	 strb r3,[r7,#35]
 1153              	.L66:
 629:../SSC/Src/sdoserv.c ****                 }
 630:../SSC/Src/sdoserv.c ****             }
 631:../SSC/Src/sdoserv.c **** 
 632:../SSC/Src/sdoserv.c ****             if ( command == SDOSERVICE_INITIATEDOWNLOADREQ )
 1154              	 .loc 1 632 0
 1155 0114 7B7E     	 ldrb r3,[r7,#25]
 1156 0116 202B     	 cmp r3,#32
 1157 0118 3CD1     	 bne .L67
 633:../SSC/Src/sdoserv.c ****             {
 634:../SSC/Src/sdoserv.c ****                 /* SDO Download */
 635:../SSC/Src/sdoserv.c ****                 if ( bTransferType )
 1158              	 .loc 1 635 0
 1159 011a 97F82330 	 ldrb r3,[r7,#35]
 1160 011e 002B     	 cmp r3,#0
 1161 0120 0FD0     	 beq .L68
 636:../SSC/Src/sdoserv.c ****                 {
 637:../SSC/Src/sdoserv.c ****                     /* Expedited Download */
 638:../SSC/Src/sdoserv.c ****                     if ( mbxSize != EXPEDITED_FRAME_SIZE )
 1162              	 .loc 1 638 0
 1163 0122 FB8A     	 ldrh r3,[r7,#22]
 1164 0124 0A2B     	 cmp r3,#10
 1165 0126 01D0     	 beq .L69
 639:../SSC/Src/sdoserv.c ****                         /* an Expedited SDO Download request has always a fixed size (2 Byte CoE-He
 640:../SSC/Src/sdoserv.c ****                         return MBXERR_INVALIDSIZE;
 1166              	 .loc 1 640 0
 1167 0128 0823     	 movs r3,#8
 1168 012a FDE1     	 b .L55
 1169              	.L69:
 641:../SSC/Src/sdoserv.c ****                     /* dataSize gets the real size of the downloaded object data (1,2,3 or 4) */
 642:../SSC/Src/sdoserv.c ****                     dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEAD
 1170              	 .loc 1 642 0
 1171 012c BB7E     	 ldrb r3,[r7,#26]
 1172 012e 03F00C03 	 and r3,r3,#12
 1173 0132 9B10     	 asrs r3,r3,#2
 1174 0134 C3F10403 	 rsb r3,r3,#4
 1175 0138 7B62     	 str r3,[r7,#36]
 643:../SSC/Src/sdoserv.c ****                     /* pData is the pointer to the downloaded object data */
 644:../SSC/Src/sdoserv.c ****                     pData = (UINT16 MBXMEM *) &pSdoInd[1];
 1176              	 .loc 1 644 0
 1177 013a 7B68     	 ldr r3,[r7,#4]
 1178 013c 0C33     	 adds r3,r3,#12
 1179 013e FB61     	 str r3,[r7,#28]
 1180 0140 28E0     	 b .L67
 1181              	.L68:
 1182              	.LBB6:
 645:../SSC/Src/sdoserv.c ****                 }
 646:../SSC/Src/sdoserv.c ****                 else
 647:../SSC/Src/sdoserv.c ****                 {
 648:../SSC/Src/sdoserv.c ****                     /* Normal Download */
 649:../SSC/Src/sdoserv.c ****                     /* downloadSize gets the real size of the downloaded data */
 650:../SSC/Src/sdoserv.c ****                     /* '&' operator was too much */
 651:../SSC/Src/sdoserv.c **** 
 652:../SSC/Src/sdoserv.c ****                     UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *)
 1183              	 .loc 1 652 0
 1184 0142 7B68     	 ldr r3,[r7,#4]
 1185 0144 DB89     	 ldrh r3,[r3,#14]
 1186 0146 1B04     	 lsls r3,r3,#16
 1187 0148 7A68     	 ldr r2,[r7,#4]
 1188 014a 9289     	 ldrh r2,[r2,#12]
 1189 014c 1344     	 add r3,r3,r2
 1190 014e BB60     	 str r3,[r7,#8]
 653:../SSC/Src/sdoserv.c **** 
 654:../SSC/Src/sdoserv.c ****                     /* HBu 29.03.06: if it is a segmented download the mbxSize has to be the comple
 655:../SSC/Src/sdoserv.c ****                     if ( (MBX_HEADER_SIZE+EXPEDITED_FRAME_SIZE+downloadSize) > u16ReceiveMbxSize )
 1191              	 .loc 1 655 0
 1192 0150 BB68     	 ldr r3,[r7,#8]
 1193 0152 1033     	 adds r3,r3,#16
 1194 0154 524A     	 ldr r2,.L94+8
 1195 0156 1288     	 ldrh r2,[r2]
 1196 0158 9342     	 cmp r3,r2
 1197 015a 07D9     	 bls .L70
 656:../SSC/Src/sdoserv.c ****                     {
 657:../SSC/Src/sdoserv.c ****                         if ( mbxSize != (u16ReceiveMbxSize-MBX_HEADER_SIZE) )
 1198              	 .loc 1 657 0
 1199 015c FA8A     	 ldrh r2,[r7,#22]
 1200 015e 504B     	 ldr r3,.L94+8
 1201 0160 1B88     	 ldrh r3,[r3]
 1202 0162 063B     	 subs r3,r3,#6
 1203 0164 9A42     	 cmp r2,r3
 1204 0166 08D0     	 beq .L71
 658:../SSC/Src/sdoserv.c ****                             return MBXERR_INVALIDSIZE;
 1205              	 .loc 1 658 0
 1206 0168 0823     	 movs r3,#8
 1207 016a DDE1     	 b .L55
 1208              	.L70:
 659:../SSC/Src/sdoserv.c ****                     }
 660:../SSC/Src/sdoserv.c ****                     else
 661:../SSC/Src/sdoserv.c ****                     {
 662:../SSC/Src/sdoserv.c ****                         if ( mbxSize != (EXPEDITED_FRAME_SIZE+downloadSize) )
 1209              	 .loc 1 662 0
 1210 016c FA8A     	 ldrh r2,[r7,#22]
 1211 016e BB68     	 ldr r3,[r7,#8]
 1212 0170 0A33     	 adds r3,r3,#10
 1213 0172 9A42     	 cmp r2,r3
 1214 0174 01D0     	 beq .L71
 663:../SSC/Src/sdoserv.c ****                             /* the mbxSize and the downloadSize are not consistent (mbxSize = downl
 664:../SSC/Src/sdoserv.c ****                             return MBXERR_INVALIDSIZE;
 1215              	 .loc 1 664 0
 1216 0176 0823     	 movs r3,#8
 1217 0178 D6E1     	 b .L55
 1218              	.L71:
 665:../SSC/Src/sdoserv.c ****                     }
 666:../SSC/Src/sdoserv.c **** 
 667:../SSC/Src/sdoserv.c ****                     /* pData is the pointer to the downloaded object data */
 668:../SSC/Src/sdoserv.c ****                     pData = (UINT16 MBXMEM *) ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data
 1219              	 .loc 1 668 0
 1220 017a 7B68     	 ldr r3,[r7,#4]
 1221 017c 1033     	 adds r3,r3,#16
 1222 017e FB61     	 str r3,[r7,#28]
 669:../SSC/Src/sdoserv.c ****                     /* the received dataSize will be checked in the object specific functions calle
 670:../SSC/Src/sdoserv.c ****                        OBJ_Write (in objdef.c) */
 671:../SSC/Src/sdoserv.c ****                     dataSize = downloadSize;
 1223              	 .loc 1 671 0
 1224 0180 BB68     	 ldr r3,[r7,#8]
 1225 0182 7B62     	 str r3,[r7,#36]
 672:../SSC/Src/sdoserv.c ****                     if ( dataSize > (UINT32)(mbxSize - DOWNLOAD_NORM_REQ_SIZE) )
 1226              	 .loc 1 672 0
 1227 0184 FB8A     	 ldrh r3,[r7,#22]
 1228 0186 A3F10A02 	 sub r2,r3,#10
 1229 018a 7B6A     	 ldr r3,[r7,#36]
 1230 018c 9A42     	 cmp r2,r3
 1231 018e 01D2     	 bcs .L67
 673:../SSC/Src/sdoserv.c ****                         /* Segmented Download */
 674:../SSC/Src/sdoserv.c ****                         segTransfer = 1;
 1232              	 .loc 1 674 0
 1233 0190 0123     	 movs r3,#1
 1234 0192 FB76     	 strb r3,[r7,#27]
 1235              	.L67:
 1236              	.LBE6:
 675:../SSC/Src/sdoserv.c ****                 }
 676:../SSC/Src/sdoserv.c ****             }
 677:../SSC/Src/sdoserv.c **** 
 678:../SSC/Src/sdoserv.c ****             if ( sdoHeader & SDOHEADER_COMPLETEACCESS )
 1237              	 .loc 1 678 0
 1238 0194 BB7E     	 ldrb r3,[r7,#26]
 1239 0196 03F01003 	 and r3,r3,#16
 1240 019a 002B     	 cmp r3,#0
 1241 019c 08D0     	 beq .L72
 679:../SSC/Src/sdoserv.c ****             {
 680:../SSC/Src/sdoserv.c ****                 bCompleteAccess = 1;
 1242              	 .loc 1 680 0
 1243 019e 0123     	 movs r3,#1
 1244 01a0 87F82E30 	 strb r3,[r7,#46]
 681:../SSC/Src/sdoserv.c ****                 // HBu 02.05.06: Complete Access is only supported with subindex 0 and 1
 682:../SSC/Src/sdoserv.c ****                 if (subindex > 1)
 1245              	 .loc 1 682 0
 1246 01a4 FB7C     	 ldrb r3,[r7,#19]
 1247 01a6 012B     	 cmp r3,#1
 1248 01a8 02D9     	 bls .L72
 683:../SSC/Src/sdoserv.c ****                     abort = ABORTIDX_UNSUPPORTED_ACCESS;
 1249              	 .loc 1 683 0
 1250 01aa 0523     	 movs r3,#5
 1251 01ac 87F82F30 	 strb r3,[r7,#47]
 1252              	.L72:
 684:../SSC/Src/sdoserv.c ****             }
 685:../SSC/Src/sdoserv.c **** 
 686:../SSC/Src/sdoserv.c ****             if ( abort == 0 )
 1253              	 .loc 1 686 0
 1254 01b0 97F82F30 	 ldrb r3,[r7,#47]
 1255 01b4 002B     	 cmp r3,#0
 1256 01b6 40F07E81 	 bne .L73
 687:../SSC/Src/sdoserv.c ****             {
 688:../SSC/Src/sdoserv.c ****                 if ( segTransfer )
 1257              	 .loc 1 688 0
 1258 01ba FB7E     	 ldrb r3,[r7,#27]
 1259 01bc 002B     	 cmp r3,#0
 1260 01be 00F0D780 	 beq .L74
 689:../SSC/Src/sdoserv.c ****                 {
 690:../SSC/Src/sdoserv.c ****                     bSdoSegFollows         = TRUE;
 1261              	 .loc 1 690 0
 1262 01c2 384B     	 ldr r3,.L94+12
 1263 01c4 0122     	 movs r2,#1
 1264 01c6 1A70     	 strb r2,[r3]
 691:../SSC/Src/sdoserv.c ****                     bSdoSegLastToggle     = 1;
 1265              	 .loc 1 691 0
 1266 01c8 374B     	 ldr r3,.L94+16
 1267 01ca 0122     	 movs r2,#1
 1268 01cc 1A70     	 strb r2,[r3]
 692:../SSC/Src/sdoserv.c ****                     bSdoSegAccess             = bCompleteAccess;
 1269              	 .loc 1 692 0
 1270 01ce 374A     	 ldr r2,.L94+20
 1271 01d0 97F82E30 	 ldrb r3,[r7,#46]
 1272 01d4 1370     	 strb r3,[r2]
 693:../SSC/Src/sdoserv.c ****                     nSdoSegIndex             = index;
 1273              	 .loc 1 693 0
 1274 01d6 364A     	 ldr r2,.L94+24
 1275 01d8 BB8A     	 ldrh r3,[r7,#20]
 1276 01da 1380     	 strh r3,[r2]
 694:../SSC/Src/sdoserv.c ****                     nSdoSegSubindex         = subindex;
 1277              	 .loc 1 694 0
 1278 01dc 354A     	 ldr r2,.L94+28
 1279 01de FB7C     	 ldrb r3,[r7,#19]
 1280 01e0 1370     	 strb r3,[r2]
 695:../SSC/Src/sdoserv.c ****                     pSdoSegObjEntry        = pObjEntry;
 1281              	 .loc 1 695 0
 1282 01e2 354A     	 ldr r2,.L94+32
 1283 01e4 FB68     	 ldr r3,[r7,#12]
 1284 01e6 1360     	 str r3,[r2]
 696:../SSC/Src/sdoserv.c ****                     if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 1285              	 .loc 1 696 0
 1286 01e8 7B7E     	 ldrb r3,[r7,#25]
 1287 01ea 402B     	 cmp r3,#64
 1288 01ec 03D1     	 bne .L75
 697:../SSC/Src/sdoserv.c ****                         nSdoSegCompleteSize    = objLength;
 1289              	 .loc 1 697 0
 1290 01ee 334A     	 ldr r2,.L94+36
 1291 01f0 BB6A     	 ldr r3,[r7,#40]
 1292 01f2 1360     	 str r3,[r2]
 1293 01f4 02E0     	 b .L76
 1294              	.L75:
 698:../SSC/Src/sdoserv.c ****                     else
 699:../SSC/Src/sdoserv.c ****                         nSdoSegCompleteSize    = dataSize;
 1295              	 .loc 1 699 0
 1296 01f6 314A     	 ldr r2,.L94+36
 1297 01f8 7B6A     	 ldr r3,[r7,#36]
 1298 01fa 1360     	 str r3,[r2]
 1299              	.L76:
 700:../SSC/Src/sdoserv.c **** 
 701:../SSC/Src/sdoserv.c ****                     if (pSdoSegData != NULL)
 1300              	 .loc 1 701 0
 1301 01fc 304B     	 ldr r3,.L94+40
 1302 01fe 1B68     	 ldr r3,[r3]
 1303 0200 002B     	 cmp r3,#0
 1304 0202 07D0     	 beq .L77
 702:../SSC/Src/sdoserv.c ****                     {
 703:../SSC/Src/sdoserv.c ****                         FREEMEM( (UINT16 VARMEM *) pSdoSegData);
 1305              	 .loc 1 703 0
 1306 0204 2E4B     	 ldr r3,.L94+40
 1307 0206 1B68     	 ldr r3,[r3]
 1308 0208 1846     	 mov r0,r3
 1309 020a FFF7FEFF 	 bl free
 704:../SSC/Src/sdoserv.c ****                         pSdoSegData = NULL;
 1310              	 .loc 1 704 0
 1311 020e 2C4B     	 ldr r3,.L94+40
 1312 0210 0022     	 movs r2,#0
 1313 0212 1A60     	 str r2,[r3]
 1314              	.L77:
 705:../SSC/Src/sdoserv.c ****                     }
 706:../SSC/Src/sdoserv.c ****                     pSdoSegData = (UINT16 VARMEM *) ALLOCMEM( ROUNDUPBYTE2WORD(nSdoSegCompleteSize)
 1315              	 .loc 1 706 0
 1316 0214 294B     	 ldr r3,.L94+36
 1317 0216 1B68     	 ldr r3,[r3]
 1318 0218 0133     	 adds r3,r3,#1
 1319 021a 23F00103 	 bic r3,r3,#1
 1320 021e 1846     	 mov r0,r3
 1321 0220 FFF7FEFF 	 bl malloc
 1322 0224 0346     	 mov r3,r0
 1323 0226 1A46     	 mov r2,r3
 1324 0228 254B     	 ldr r3,.L94+40
 1325 022a 1A60     	 str r2,[r3]
 707:../SSC/Src/sdoserv.c **** 
 708:../SSC/Src/sdoserv.c ****                     if ( pSdoSegData == NULL )
 1326              	 .loc 1 708 0
 1327 022c 244B     	 ldr r3,.L94+40
 1328 022e 1B68     	 ldr r3,[r3]
 1329 0230 002B     	 cmp r3,#0
 1330 0232 0BD1     	 bne .L78
 709:../SSC/Src/sdoserv.c ****                     {
 710:../SSC/Src/sdoserv.c **** /*ECATCHANGE_START(V5.11) SDO4*/
 711:../SSC/Src/sdoserv.c ****                         if(bCompleteAccess)
 1331              	 .loc 1 711 0
 1332 0234 97F82E30 	 ldrb r3,[r7,#46]
 1333 0238 002B     	 cmp r3,#0
 1334 023a 03D0     	 beq .L79
 712:../SSC/Src/sdoserv.c ****                             abort = ABORTIDX_UNSUPPORTED_ACCESS;
 1335              	 .loc 1 712 0
 1336 023c 0523     	 movs r3,#5
 1337 023e 87F82F30 	 strb r3,[r7,#47]
 1338 0242 38E1     	 b .L73
 1339              	.L79:
 713:../SSC/Src/sdoserv.c ****                         else
 714:../SSC/Src/sdoserv.c **** /*ECATCHANGE_END(V5.11) SDO4*/
 715:../SSC/Src/sdoserv.c ****                             abort = ABORTIDX_OUT_OF_MEMORY;
 1340              	 .loc 1 715 0
 1341 0244 0423     	 movs r3,#4
 1342 0246 87F82F30 	 strb r3,[r7,#47]
 1343 024a 34E1     	 b .L73
 1344              	.L78:
 716:../SSC/Src/sdoserv.c ****                     }
 717:../SSC/Src/sdoserv.c ****                     else
 718:../SSC/Src/sdoserv.c ****                     {
 719:../SSC/Src/sdoserv.c ****                         if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 1345              	 .loc 1 719 0
 1346 024c 7B7E     	 ldrb r3,[r7,#25]
 1347 024e 402B     	 cmp r3,#64
 1348 0250 78D1     	 bne .L82
 720:../SSC/Src/sdoserv.c ****                         {
 721:../SSC/Src/sdoserv.c ****                             /* Segmented Upload */
 722:../SSC/Src/sdoserv.c ****                             abort = OBJ_Read( index, subindex, objLength, pObjEntry, (UINT16 MBXMEM
 1349              	 .loc 1 722 0
 1350 0252 1B4B     	 ldr r3,.L94+40
 1351 0254 1B68     	 ldr r3,[r3]
 1352 0256 B98A     	 ldrh r1,[r7,#20]
 1353 0258 FA7C     	 ldrb r2,[r7,#19]
 1354 025a 0093     	 str r3,[sp]
 1355 025c 97F82E30 	 ldrb r3,[r7,#46]
 1356 0260 0193     	 str r3,[sp,#4]
 1357 0262 0846     	 mov r0,r1
 1358 0264 1146     	 mov r1,r2
 1359 0266 BA6A     	 ldr r2,[r7,#40]
 1360 0268 FB68     	 ldr r3,[r7,#12]
 1361 026a FFF7FEFF 	 bl OBJ_Read
 1362 026e 0346     	 mov r3,r0
 1363 0270 87F82F30 	 strb r3,[r7,#47]
 723:../SSC/Src/sdoserv.c ****                             if ( abort == 0 )
 1364              	 .loc 1 723 0
 1365 0274 97F82F30 	 ldrb r3,[r7,#47]
 1366 0278 002B     	 cmp r3,#0
 1367 027a 25D1     	 bne .L83
 724:../SSC/Src/sdoserv.c ****                             {
 725:../SSC/Src/sdoserv.c ****                                 MBXMEMCPY( ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data, pSd
 1368              	 .loc 1 725 0
 1369 027c 7B68     	 ldr r3,[r7,#4]
 1370 027e 03F11002 	 add r2,r3,#16
 1371 0282 0F4B     	 ldr r3,.L94+40
 1372 0284 1B68     	 ldr r3,[r3]
 1373 0286 1046     	 mov r0,r2
 1374 0288 1946     	 mov r1,r3
 1375 028a 7A6A     	 ldr r2,[r7,#36]
 1376 028c FFF7FEFF 	 bl memcpy
 726:../SSC/Src/sdoserv.c ****                                 nSdoSegService    = SDOSERVICE_UPLOADSEGMENTREQ;
 1377              	 .loc 1 726 0
 1378 0290 0C4B     	 ldr r3,.L94+44
 1379 0292 6022     	 movs r2,#96
 1380 0294 1A70     	 strb r2,[r3]
 1381 0296 67E0     	 b .L84
 1382              	.L95:
 1383              	 .align 2
 1384              	.L94:
 1385 0298 00000000 	 .word bSdoInWork
 1386 029c 00000000 	 .word u16SendMbxSize
 1387 02a0 00000000 	 .word u16ReceiveMbxSize
 1388 02a4 00000000 	 .word bSdoSegFollows
 1389 02a8 00000000 	 .word bSdoSegLastToggle
 1390 02ac 00000000 	 .word bSdoSegAccess
 1391 02b0 00000000 	 .word nSdoSegIndex
 1392 02b4 00000000 	 .word nSdoSegSubindex
 1393 02b8 00000000 	 .word pSdoSegObjEntry
 1394 02bc 00000000 	 .word nSdoSegCompleteSize
 1395 02c0 00000000 	 .word pSdoSegData
 1396 02c4 00000000 	 .word nSdoSegService
 1397              	.L83:
 727:../SSC/Src/sdoserv.c ****                             }
 728:../SSC/Src/sdoserv.c ****                             else if ( abort == ABORTIDX_WORKING )
 1398              	 .loc 1 728 0
 1399 02c8 97F82F30 	 ldrb r3,[r7,#47]
 1400 02cc FF2B     	 cmp r3,#255
 1401 02ce 4BD1     	 bne .L84
 729:../SSC/Src/sdoserv.c ****                             {
 730:../SSC/Src/sdoserv.c ****                                 /* the application generates the SDO-Response later on by calling S
 731:../SSC/Src/sdoserv.c ****                                 u8PendingSdo = SDO_PENDING_SEG_READ;
 1402              	 .loc 1 731 0
 1403 02d0 974B     	 ldr r3,.L96
 1404 02d2 0422     	 movs r2,#4
 1405 02d4 1A70     	 strb r2,[r3]
 732:../SSC/Src/sdoserv.c ****                                 bStoreCompleteAccess = bCompleteAccess;
 1406              	 .loc 1 732 0
 1407 02d6 97F82E30 	 ldrb r3,[r7,#46]
 1408 02da 002B     	 cmp r3,#0
 1409 02dc 14BF     	 ite ne
 1410 02de 0123     	 movne r3,#1
 1411 02e0 0023     	 moveq r3,#0
 1412 02e2 DAB2     	 uxtb r2,r3
 1413 02e4 934B     	 ldr r3,.L96+4
 1414 02e6 1A70     	 strb r2,[r3]
 733:../SSC/Src/sdoserv.c ****                                 u8StoreSubindex = subindex;
 1415              	 .loc 1 733 0
 1416 02e8 934A     	 ldr r2,.L96+8
 1417 02ea FB7C     	 ldrb r3,[r7,#19]
 1418 02ec 1370     	 strb r3,[r2]
 734:../SSC/Src/sdoserv.c ****                                 u16StoreIndex = index;
 1419              	 .loc 1 734 0
 1420 02ee 934A     	 ldr r2,.L96+12
 1421 02f0 BB8A     	 ldrh r3,[r7,#20]
 1422 02f2 1380     	 strh r3,[r2]
 735:../SSC/Src/sdoserv.c ****                                 u32StoreDataSize = objLength;
 1423              	 .loc 1 735 0
 1424 02f4 924A     	 ldr r2,.L96+16
 1425 02f6 BB6A     	 ldr r3,[r7,#40]
 1426 02f8 1360     	 str r3,[r2]
 736:../SSC/Src/sdoserv.c ****                                 pStoreData = pSdoSegData;
 1427              	 .loc 1 736 0
 1428 02fa 924B     	 ldr r3,.L96+20
 1429 02fc 1B68     	 ldr r3,[r3]
 1430 02fe 924A     	 ldr r2,.L96+24
 1431 0300 1360     	 str r3,[r2]
 737:../SSC/Src/sdoserv.c ****                                 pSdoPendFunc = pObjEntry->Read;
 1432              	 .loc 1 737 0
 1433 0302 FB68     	 ldr r3,[r7,#12]
 1434 0304 DB69     	 ldr r3,[r3,#28]
 1435 0306 914A     	 ldr r2,.L96+28
 1436 0308 1360     	 str r3,[r2]
 738:../SSC/Src/sdoserv.c **** 
 739:../SSC/Src/sdoserv.c ****                                 bSdoInWork = TRUE;
 1437              	 .loc 1 739 0
 1438 030a 914B     	 ldr r3,.L96+32
 1439 030c 0122     	 movs r2,#1
 1440 030e 1A70     	 strb r2,[r3]
 740:../SSC/Src/sdoserv.c ****                                 /* we have to store the buffer and the response header */
 741:../SSC/Src/sdoserv.c ****                                 pSdoResStored = pSdoInd;
 1441              	 .loc 1 741 0
 1442 0310 904A     	 ldr r2,.L96+36
 1443 0312 7B68     	 ldr r3,[r7,#4]
 1444 0314 1360     	 str r3,[r2]
 742:../SSC/Src/sdoserv.c **** 
 743:../SSC/Src/sdoserv.c ****                                 /*update command field*/
 744:../SSC/Src/sdoserv.c ****                                 pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]   &= ~SDOHEAD
 1445              	 .loc 1 744 0
 1446 0316 8F4B     	 ldr r3,.L96+36
 1447 0318 1B68     	 ldr r3,[r3]
 1448 031a 0022     	 movs r2,#0
 1449 031c 1A72     	 strb r2,[r3,#8]
 745:../SSC/Src/sdoserv.c ****                                 pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]   |= (sdoHead
 1450              	 .loc 1 745 0
 1451 031e 8D4B     	 ldr r3,.L96+36
 1452 0320 1B68     	 ldr r3,[r3]
 1453 0322 8C4A     	 ldr r2,.L96+36
 1454 0324 1268     	 ldr r2,[r2]
 1455 0326 127A     	 ldrb r2,[r2,#8]
 1456 0328 D1B2     	 uxtb r1,r2
 1457 032a BA7E     	 ldrb r2,[r7,#26]
 1458 032c 22F00F02 	 bic r2,r2,#15
 1459 0330 D2B2     	 uxtb r2,r2
 1460 0332 0A43     	 orrs r2,r2,r1
 1461 0334 D2B2     	 uxtb r2,r2
 1462 0336 D2B2     	 uxtb r2,r2
 1463 0338 1A72     	 strb r2,[r3,#8]
 746:../SSC/Src/sdoserv.c ****                                 nSdoSegService    = SDOSERVICE_UPLOADSEGMENTREQ;
 1464              	 .loc 1 746 0
 1465 033a 874B     	 ldr r3,.L96+40
 1466 033c 6022     	 movs r2,#96
 1467 033e 1A70     	 strb r2,[r3]
 747:../SSC/Src/sdoserv.c ****                                 return 0;
 1468              	 .loc 1 747 0
 1469 0340 0023     	 movs r3,#0
 1470 0342 F1E0     	 b .L55
 1471              	.L82:
 748:../SSC/Src/sdoserv.c ****                             }
 749:../SSC/Src/sdoserv.c ****                         }
 750:../SSC/Src/sdoserv.c ****                         else
 751:../SSC/Src/sdoserv.c ****                         {
 752:../SSC/Src/sdoserv.c ****                             /* Segmented Download */
 753:../SSC/Src/sdoserv.c ****                             MBXMEMCPY( pSdoSegData, ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)
 1472              	 .loc 1 753 0
 1473 0344 7F4B     	 ldr r3,.L96+20
 1474 0346 1968     	 ldr r1,[r3]
 1475 0348 7B68     	 ldr r3,[r7,#4]
 1476 034a 03F11002 	 add r2,r3,#16
 1477 034e FB8A     	 ldrh r3,[r7,#22]
 1478 0350 0A3B     	 subs r3,r3,#10
 1479 0352 0846     	 mov r0,r1
 1480 0354 1146     	 mov r1,r2
 1481 0356 1A46     	 mov r2,r3
 1482 0358 FFF7FEFF 	 bl memcpy
 754:../SSC/Src/sdoserv.c ****                             nSdoSegService    = SDOSERVICE_DOWNLOADSEGMENTREQ;
 1483              	 .loc 1 754 0
 1484 035c 7E4B     	 ldr r3,.L96+40
 1485 035e 0022     	 movs r2,#0
 1486 0360 1A70     	 strb r2,[r3]
 755:../SSC/Src/sdoserv.c ****                             dataSize = (mbxSize-DOWNLOAD_NORM_REQ_SIZE);
 1487              	 .loc 1 755 0
 1488 0362 FB8A     	 ldrh r3,[r7,#22]
 1489 0364 0A3B     	 subs r3,r3,#10
 1490 0366 7B62     	 str r3,[r7,#36]
 1491              	.L84:
 756:../SSC/Src/sdoserv.c ****                         }
 757:../SSC/Src/sdoserv.c **** 
 758:../SSC/Src/sdoserv.c ****                         nSdoSegBytesToHandle = dataSize;
 1492              	 .loc 1 758 0
 1493 0368 7C4A     	 ldr r2,.L96+44
 1494 036a 7B6A     	 ldr r3,[r7,#36]
 1495 036c 1360     	 str r3,[r2]
 1496              	.LBE5:
 1497 036e A7E0     	 b .L87
 1498              	.L74:
 1499              	.LBB7:
 759:../SSC/Src/sdoserv.c ****                     }
 760:../SSC/Src/sdoserv.c ****                 }
 761:../SSC/Src/sdoserv.c ****                 else
 762:../SSC/Src/sdoserv.c ****                 {
 763:../SSC/Src/sdoserv.c ****                     if ( objLength == 0 )
 1500              	 .loc 1 763 0
 1501 0370 BB6A     	 ldr r3,[r7,#40]
 1502 0372 002B     	 cmp r3,#0
 1503 0374 08D1     	 bne .L85
 764:../SSC/Src/sdoserv.c ****                     {
 765:../SSC/Src/sdoserv.c ****                         /* the objLength is not known, therefore the variables for a possible segme
 766:../SSC/Src/sdoserv.c ****                             should be initialized */
 767:../SSC/Src/sdoserv.c ****                         nSdoSegIndex             = index;
 1504              	 .loc 1 767 0
 1505 0376 7A4A     	 ldr r2,.L96+48
 1506 0378 BB8A     	 ldrh r3,[r7,#20]
 1507 037a 1380     	 strh r3,[r2]
 768:../SSC/Src/sdoserv.c ****                         nSdoSegSubindex         = subindex;
 1508              	 .loc 1 768 0
 1509 037c 794A     	 ldr r2,.L96+52
 1510 037e FB7C     	 ldrb r3,[r7,#19]
 1511 0380 1370     	 strb r3,[r2]
 769:../SSC/Src/sdoserv.c ****                         pSdoSegObjEntry        = pObjEntry;
 1512              	 .loc 1 769 0
 1513 0382 794A     	 ldr r2,.L96+56
 1514 0384 FB68     	 ldr r3,[r7,#12]
 1515 0386 1360     	 str r3,[r2]
 1516              	.L85:
 770:../SSC/Src/sdoserv.c ****                     }
 771:../SSC/Src/sdoserv.c ****                     if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 1517              	 .loc 1 771 0
 1518 0388 7B7E     	 ldrb r3,[r7,#25]
 1519 038a 402B     	 cmp r3,#64
 1520 038c 49D1     	 bne .L86
 772:../SSC/Src/sdoserv.c ****                     {
 773:../SSC/Src/sdoserv.c ****                         /* Expedited or Normal Upload */
 774:../SSC/Src/sdoserv.c ****                         abort = OBJ_Read( index, subindex, objLength, pObjEntry, pData, bCompleteAc
 1521              	 .loc 1 774 0
 1522 038e B98A     	 ldrh r1,[r7,#20]
 1523 0390 FA7C     	 ldrb r2,[r7,#19]
 1524 0392 FB69     	 ldr r3,[r7,#28]
 1525 0394 0093     	 str r3,[sp]
 1526 0396 97F82E30 	 ldrb r3,[r7,#46]
 1527 039a 0193     	 str r3,[sp,#4]
 1528 039c 0846     	 mov r0,r1
 1529 039e 1146     	 mov r1,r2
 1530 03a0 BA6A     	 ldr r2,[r7,#40]
 1531 03a2 FB68     	 ldr r3,[r7,#12]
 1532 03a4 FFF7FEFF 	 bl OBJ_Read
 1533 03a8 0346     	 mov r3,r0
 1534 03aa 87F82F30 	 strb r3,[r7,#47]
 775:../SSC/Src/sdoserv.c ****                         if ( abort == ABORTIDX_WORKING )
 1535              	 .loc 1 775 0
 1536 03ae 97F82F30 	 ldrb r3,[r7,#47]
 1537 03b2 FF2B     	 cmp r3,#255
 1538 03b4 7FD1     	 bne .L73
 776:../SSC/Src/sdoserv.c ****                         {
 777:../SSC/Src/sdoserv.c ****                             /* the application generates the SDO-Response later on by calling SDOS_
 778:../SSC/Src/sdoserv.c ****                             u8PendingSdo = SDO_PENDING_READ;
 1539              	 .loc 1 778 0
 1540 03b6 5E4B     	 ldr r3,.L96
 1541 03b8 0322     	 movs r2,#3
 1542 03ba 1A70     	 strb r2,[r3]
 779:../SSC/Src/sdoserv.c ****                             bStoreCompleteAccess = bCompleteAccess;
 1543              	 .loc 1 779 0
 1544 03bc 97F82E30 	 ldrb r3,[r7,#46]
 1545 03c0 002B     	 cmp r3,#0
 1546 03c2 14BF     	 ite ne
 1547 03c4 0123     	 movne r3,#1
 1548 03c6 0023     	 moveq r3,#0
 1549 03c8 DAB2     	 uxtb r2,r3
 1550 03ca 5A4B     	 ldr r3,.L96+4
 1551 03cc 1A70     	 strb r2,[r3]
 780:../SSC/Src/sdoserv.c ****                             u8StoreSubindex = subindex;
 1552              	 .loc 1 780 0
 1553 03ce 5A4A     	 ldr r2,.L96+8
 1554 03d0 FB7C     	 ldrb r3,[r7,#19]
 1555 03d2 1370     	 strb r3,[r2]
 781:../SSC/Src/sdoserv.c ****                             u16StoreIndex = index;
 1556              	 .loc 1 781 0
 1557 03d4 594A     	 ldr r2,.L96+12
 1558 03d6 BB8A     	 ldrh r3,[r7,#20]
 1559 03d8 1380     	 strh r3,[r2]
 782:../SSC/Src/sdoserv.c ****                             u32StoreDataSize = objLength;
 1560              	 .loc 1 782 0
 1561 03da 594A     	 ldr r2,.L96+16
 1562 03dc BB6A     	 ldr r3,[r7,#40]
 1563 03de 1360     	 str r3,[r2]
 783:../SSC/Src/sdoserv.c ****                             pStoreData = pData;
 1564              	 .loc 1 783 0
 1565 03e0 594A     	 ldr r2,.L96+24
 1566 03e2 FB69     	 ldr r3,[r7,#28]
 1567 03e4 1360     	 str r3,[r2]
 784:../SSC/Src/sdoserv.c ****                             pSdoPendFunc = pObjEntry->Read;
 1568              	 .loc 1 784 0
 1569 03e6 FB68     	 ldr r3,[r7,#12]
 1570 03e8 DB69     	 ldr r3,[r3,#28]
 1571 03ea 584A     	 ldr r2,.L96+28
 1572 03ec 1360     	 str r3,[r2]
 785:../SSC/Src/sdoserv.c **** 
 786:../SSC/Src/sdoserv.c ****                             bSdoInWork = TRUE;
 1573              	 .loc 1 786 0
 1574 03ee 584B     	 ldr r3,.L96+32
 1575 03f0 0122     	 movs r2,#1
 1576 03f2 1A70     	 strb r2,[r3]
 787:../SSC/Src/sdoserv.c ****                             /* we have to store the buffer and the response header */
 788:../SSC/Src/sdoserv.c ****                             pSdoResStored = pSdoInd;
 1577              	 .loc 1 788 0
 1578 03f4 574A     	 ldr r2,.L96+36
 1579 03f6 7B68     	 ldr r3,[r7,#4]
 1580 03f8 1360     	 str r3,[r2]
 789:../SSC/Src/sdoserv.c ****                             
 790:../SSC/Src/sdoserv.c ****                             /*update command field*/
 791:../SSC/Src/sdoserv.c ****                             pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COM
 1581              	 .loc 1 791 0
 1582 03fa 564B     	 ldr r3,.L96+36
 1583 03fc 1B68     	 ldr r3,[r3]
 1584 03fe 0022     	 movs r2,#0
 1585 0400 1A72     	 strb r2,[r3,#8]
 792:../SSC/Src/sdoserv.c ****                             pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= (sdoHeader 
 1586              	 .loc 1 792 0
 1587 0402 544B     	 ldr r3,.L96+36
 1588 0404 1B68     	 ldr r3,[r3]
 1589 0406 534A     	 ldr r2,.L96+36
 1590 0408 1268     	 ldr r2,[r2]
 1591 040a 127A     	 ldrb r2,[r2,#8]
 1592 040c D1B2     	 uxtb r1,r2
 1593 040e BA7E     	 ldrb r2,[r7,#26]
 1594 0410 22F00F02 	 bic r2,r2,#15
 1595 0414 D2B2     	 uxtb r2,r2
 1596 0416 0A43     	 orrs r2,r2,r1
 1597 0418 D2B2     	 uxtb r2,r2
 1598 041a D2B2     	 uxtb r2,r2
 1599 041c 1A72     	 strb r2,[r3,#8]
 793:../SSC/Src/sdoserv.c ****                             return 0;
 1600              	 .loc 1 793 0
 1601 041e 0023     	 movs r3,#0
 1602 0420 82E0     	 b .L55
 1603              	.L86:
 794:../SSC/Src/sdoserv.c ****                         }
 795:../SSC/Src/sdoserv.c ****                     }
 796:../SSC/Src/sdoserv.c ****                     else
 797:../SSC/Src/sdoserv.c ****                     {
 798:../SSC/Src/sdoserv.c ****                         /* Expedited or Normal Download */
 799:../SSC/Src/sdoserv.c ****                         abort = OBJ_Write( index, subindex, dataSize, pObjEntry, pData, bCompleteAc
 1604              	 .loc 1 799 0
 1605 0422 B98A     	 ldrh r1,[r7,#20]
 1606 0424 FA7C     	 ldrb r2,[r7,#19]
 1607 0426 FB69     	 ldr r3,[r7,#28]
 1608 0428 0093     	 str r3,[sp]
 1609 042a 97F82E30 	 ldrb r3,[r7,#46]
 1610 042e 0193     	 str r3,[sp,#4]
 1611 0430 0846     	 mov r0,r1
 1612 0432 1146     	 mov r1,r2
 1613 0434 7A6A     	 ldr r2,[r7,#36]
 1614 0436 FB68     	 ldr r3,[r7,#12]
 1615 0438 FFF7FEFF 	 bl OBJ_Write
 1616 043c 0346     	 mov r3,r0
 1617 043e 87F82F30 	 strb r3,[r7,#47]
 800:../SSC/Src/sdoserv.c ****                         if ( abort == ABORTIDX_WORKING )
 1618              	 .loc 1 800 0
 1619 0442 97F82F30 	 ldrb r3,[r7,#47]
 1620 0446 FF2B     	 cmp r3,#255
 1621 0448 35D1     	 bne .L73
 801:../SSC/Src/sdoserv.c ****                         {
 802:../SSC/Src/sdoserv.c ****                             /* the application generates the SDO-Response later on by calling SDOS_
 803:../SSC/Src/sdoserv.c ****                             u8PendingSdo = SDO_PENDING_WRITE;
 1622              	 .loc 1 803 0
 1623 044a 394B     	 ldr r3,.L96
 1624 044c 0122     	 movs r2,#1
 1625 044e 1A70     	 strb r2,[r3]
 804:../SSC/Src/sdoserv.c ****                             bStoreCompleteAccess = bCompleteAccess;
 1626              	 .loc 1 804 0
 1627 0450 97F82E30 	 ldrb r3,[r7,#46]
 1628 0454 002B     	 cmp r3,#0
 1629 0456 14BF     	 ite ne
 1630 0458 0123     	 movne r3,#1
 1631 045a 0023     	 moveq r3,#0
 1632 045c DAB2     	 uxtb r2,r3
 1633 045e 354B     	 ldr r3,.L96+4
 1634 0460 1A70     	 strb r2,[r3]
 805:../SSC/Src/sdoserv.c ****                             u8StoreSubindex = subindex;
 1635              	 .loc 1 805 0
 1636 0462 354A     	 ldr r2,.L96+8
 1637 0464 FB7C     	 ldrb r3,[r7,#19]
 1638 0466 1370     	 strb r3,[r2]
 806:../SSC/Src/sdoserv.c ****                             u16StoreIndex = index;
 1639              	 .loc 1 806 0
 1640 0468 344A     	 ldr r2,.L96+12
 1641 046a BB8A     	 ldrh r3,[r7,#20]
 1642 046c 1380     	 strh r3,[r2]
 807:../SSC/Src/sdoserv.c ****                             u32StoreDataSize = dataSize;
 1643              	 .loc 1 807 0
 1644 046e 344A     	 ldr r2,.L96+16
 1645 0470 7B6A     	 ldr r3,[r7,#36]
 1646 0472 1360     	 str r3,[r2]
 808:../SSC/Src/sdoserv.c ****                             pStoreData = pData;
 1647              	 .loc 1 808 0
 1648 0474 344A     	 ldr r2,.L96+24
 1649 0476 FB69     	 ldr r3,[r7,#28]
 1650 0478 1360     	 str r3,[r2]
 809:../SSC/Src/sdoserv.c ****                             pSdoPendFunc = pObjEntry->Write;
 1651              	 .loc 1 809 0
 1652 047a FB68     	 ldr r3,[r7,#12]
 1653 047c 1B6A     	 ldr r3,[r3,#32]
 1654 047e 334A     	 ldr r2,.L96+28
 1655 0480 1360     	 str r3,[r2]
 810:../SSC/Src/sdoserv.c **** 
 811:../SSC/Src/sdoserv.c ****                             bSdoInWork = TRUE;
 1656              	 .loc 1 811 0
 1657 0482 334B     	 ldr r3,.L96+32
 1658 0484 0122     	 movs r2,#1
 1659 0486 1A70     	 strb r2,[r3]
 812:../SSC/Src/sdoserv.c ****                             /* we have to store the buffer and the response header */
 813:../SSC/Src/sdoserv.c ****                             pSdoResStored = pSdoInd;
 1660              	 .loc 1 813 0
 1661 0488 324A     	 ldr r2,.L96+36
 1662 048a 7B68     	 ldr r3,[r7,#4]
 1663 048c 1360     	 str r3,[r2]
 814:../SSC/Src/sdoserv.c **** 
 815:../SSC/Src/sdoserv.c ****                             /*update command field*/
 816:../SSC/Src/sdoserv.c ****                             pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COM
 1664              	 .loc 1 816 0
 1665 048e 314B     	 ldr r3,.L96+36
 1666 0490 1B68     	 ldr r3,[r3]
 1667 0492 0022     	 movs r2,#0
 1668 0494 1A72     	 strb r2,[r3,#8]
 817:../SSC/Src/sdoserv.c ****                             pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= (sdoHeader 
 1669              	 .loc 1 817 0
 1670 0496 2F4B     	 ldr r3,.L96+36
 1671 0498 1B68     	 ldr r3,[r3]
 1672 049a 2E4A     	 ldr r2,.L96+36
 1673 049c 1268     	 ldr r2,[r2]
 1674 049e 127A     	 ldrb r2,[r2,#8]
 1675 04a0 D1B2     	 uxtb r1,r2
 1676 04a2 BA7E     	 ldrb r2,[r7,#26]
 1677 04a4 22F00F02 	 bic r2,r2,#15
 1678 04a8 D2B2     	 uxtb r2,r2
 1679 04aa 0A43     	 orrs r2,r2,r1
 1680 04ac D2B2     	 uxtb r2,r2
 1681 04ae D2B2     	 uxtb r2,r2
 1682 04b0 1A72     	 strb r2,[r3,#8]
 818:../SSC/Src/sdoserv.c ****                             return 0;
 1683              	 .loc 1 818 0
 1684 04b2 0023     	 movs r3,#0
 1685 04b4 38E0     	 b .L55
 1686              	.L73:
 1687              	.LBE7:
 1688 04b6 03E0     	 b .L87
 1689              	.L60:
 819:../SSC/Src/sdoserv.c ****                         }
 820:../SSC/Src/sdoserv.c ****                     }
 821:../SSC/Src/sdoserv.c ****                 } /* else if ( objLength == 0 ) */
 822:../SSC/Src/sdoserv.c ****             } /* if ( abort == 0 ) */
 823:../SSC/Src/sdoserv.c **** 
 824:../SSC/Src/sdoserv.c ****         } //if(pEntry) (Object handle found)
 825:../SSC/Src/sdoserv.c ****         else
 826:../SSC/Src/sdoserv.c ****         {
 827:../SSC/Src/sdoserv.c ****             abort = ABORTIDX_OBJECT_NOT_EXISTING;
 1690              	 .loc 1 827 0
 1691 04b8 0823     	 movs r3,#8
 1692 04ba 87F82F30 	 strb r3,[r7,#47]
 828:../SSC/Src/sdoserv.c ****         }
 829:../SSC/Src/sdoserv.c ****         break;
 1693              	 .loc 1 829 0
 1694 04be 1EE0     	 b .L88
 1695              	.L87:
 1696              	 .loc 1 829 0 is_stmt 0 discriminator 4
 1697 04c0 1DE0     	 b .L88
 1698              	.L59:
 830:../SSC/Src/sdoserv.c **** 
 831:../SSC/Src/sdoserv.c ****     case SDOSERVICE_DOWNLOADSEGMENTREQ:
 832:../SSC/Src/sdoserv.c ****     case SDOSERVICE_UPLOADSEGMENTREQ:
 833:../SSC/Src/sdoserv.c ****         if ( command == nSdoSegService )
 1699              	 .loc 1 833 0 is_stmt 1
 1700 04c2 254B     	 ldr r3,.L96+40
 1701 04c4 1B78     	 ldrb r3,[r3]
 1702 04c6 7A7E     	 ldrb r2,[r7,#25]
 1703 04c8 9A42     	 cmp r2,r3
 1704 04ca 10D1     	 bne .L89
 834:../SSC/Src/sdoserv.c ****         {
 835:../SSC/Src/sdoserv.c ****             if ( command == SDOSERVICE_DOWNLOADSEGMENTREQ )
 1705              	 .loc 1 835 0
 1706 04cc 7B7E     	 ldrb r3,[r7,#25]
 1707 04ce 002B     	 cmp r3,#0
 1708 04d0 06D1     	 bne .L90
 836:../SSC/Src/sdoserv.c ****                 abort = SdoDownloadSegmentInd( (TDOWNLOADSDOSEGREQMBX MBXMEM *) pSdoInd );
 1709              	 .loc 1 836 0
 1710 04d2 7868     	 ldr r0,[r7,#4]
 1711 04d4 FFF7FEFF 	 bl SdoDownloadSegmentInd
 1712 04d8 0346     	 mov r3,r0
 1713 04da 87F82F30 	 strb r3,[r7,#47]
 837:../SSC/Src/sdoserv.c ****             else
 838:../SSC/Src/sdoserv.c ****                 abort = SdoUploadSegmentInd( (TUPLOADSDOSEGREQMBX MBXMEM *) pSdoInd );
 839:../SSC/Src/sdoserv.c ****         }
 840:../SSC/Src/sdoserv.c ****         else
 841:../SSC/Src/sdoserv.c ****             abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 842:../SSC/Src/sdoserv.c ****         break;
 1714              	 .loc 1 842 0
 1715 04de 0EE0     	 b .L88
 1716              	.L90:
 838:../SSC/Src/sdoserv.c ****         }
 1717              	 .loc 1 838 0
 1718 04e0 7868     	 ldr r0,[r7,#4]
 1719 04e2 FFF7FEFF 	 bl SdoUploadSegmentInd
 1720 04e6 0346     	 mov r3,r0
 1721 04e8 87F82F30 	 strb r3,[r7,#47]
 1722              	 .loc 1 842 0
 1723 04ec 07E0     	 b .L88
 1724              	.L89:
 841:../SSC/Src/sdoserv.c ****         break;
 1725              	 .loc 1 841 0
 1726 04ee 0323     	 movs r3,#3
 1727 04f0 87F82F30 	 strb r3,[r7,#47]
 1728              	 .loc 1 842 0
 1729 04f4 03E0     	 b .L88
 1730              	.L56:
 843:../SSC/Src/sdoserv.c **** 
 844:../SSC/Src/sdoserv.c ****     default:
 845:../SSC/Src/sdoserv.c ****         abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 1731              	 .loc 1 845 0
 1732 04f6 0323     	 movs r3,#3
 1733 04f8 87F82F30 	 strb r3,[r7,#47]
 846:../SSC/Src/sdoserv.c ****         break;
 1734              	 .loc 1 846 0
 1735 04fc 00BF     	 nop
 1736              	.L88:
 847:../SSC/Src/sdoserv.c ****     }
 848:../SSC/Src/sdoserv.c **** 
 849:../SSC/Src/sdoserv.c ****     if(abort != ABORTIDX_WORKING)
 1737              	 .loc 1 849 0
 1738 04fe 97F82F30 	 ldrb r3,[r7,#47]
 1739 0502 FF2B     	 cmp r3,#255
 1740 0504 0FD0     	 beq .L93
 850:../SSC/Src/sdoserv.c ****     {
 851:../SSC/Src/sdoserv.c ****         /*  type cast was added because of warning */
 852:../SSC/Src/sdoserv.c ****         SdoRes(abort, command, (UINT8) (sdoHeader & SDOHEADER_COMPLETEACCESS), (UINT16) dataSize, o
 1741              	 .loc 1 852 0
 1742 0506 BB7E     	 ldrb r3,[r7,#26]
 1743 0508 03F01003 	 and r3,r3,#16
 1744 050c DAB2     	 uxtb r2,r3
 1745 050e 7B6A     	 ldr r3,[r7,#36]
 1746 0510 9CB2     	 uxth r4,r3
 1747 0512 97F82F00 	 ldrb r0,[r7,#47]
 1748 0516 797E     	 ldrb r1,[r7,#25]
 1749 0518 BB6A     	 ldr r3,[r7,#40]
 1750 051a 0093     	 str r3,[sp]
 1751 051c 7B68     	 ldr r3,[r7,#4]
 1752 051e 0193     	 str r3,[sp,#4]
 1753 0520 2346     	 mov r3,r4
 1754 0522 FFF7FEFF 	 bl SdoRes
 1755              	.L93:
 853:../SSC/Src/sdoserv.c ****     }
 854:../SSC/Src/sdoserv.c **** 
 855:../SSC/Src/sdoserv.c ****     return 0;
 1756              	 .loc 1 855 0
 1757 0526 0023     	 movs r3,#0
 1758              	.L55:
 856:../SSC/Src/sdoserv.c **** }
 1759              	 .loc 1 856 0
 1760 0528 1846     	 mov r0,r3
 1761 052a 3437     	 adds r7,r7,#52
 1762              	.LCFI18:
 1763              	 .cfi_def_cfa_offset 12
 1764 052c BD46     	 mov sp,r7
 1765              	.LCFI19:
 1766              	 .cfi_def_cfa_register 13
 1767              	 
 1768 052e 90BD     	 pop {r4,r7,pc}
 1769              	.L97:
 1770              	 .align 2
 1771              	.L96:
 1772 0530 00000000 	 .word u8PendingSdo
 1773 0534 00000000 	 .word bStoreCompleteAccess
 1774 0538 00000000 	 .word u8StoreSubindex
 1775 053c 00000000 	 .word u16StoreIndex
 1776 0540 00000000 	 .word u32StoreDataSize
 1777 0544 00000000 	 .word pSdoSegData
 1778 0548 00000000 	 .word pStoreData
 1779 054c 00000000 	 .word pSdoPendFunc
 1780 0550 00000000 	 .word bSdoInWork
 1781 0554 00000000 	 .word pSdoResStored
 1782 0558 00000000 	 .word nSdoSegService
 1783 055c 00000000 	 .word nSdoSegBytesToHandle
 1784 0560 00000000 	 .word nSdoSegIndex
 1785 0564 00000000 	 .word nSdoSegSubindex
 1786 0568 00000000 	 .word pSdoSegObjEntry
 1787              	 .cfi_endproc
 1788              	.LFE175:
 1790              	 .section .text.SDOS_SdoRes,"ax",%progbits
 1791              	 .align 2
 1792              	 .global SDOS_SdoRes
 1793              	 .thumb
 1794              	 .thumb_func
 1796              	SDOS_SdoRes:
 1797              	.LFB176:
 857:../SSC/Src/sdoserv.c **** 
 858:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 859:../SSC/Src/sdoserv.c **** /**
 860:../SSC/Src/sdoserv.c ****  \param    abort                Result of the SDO access
 861:../SSC/Src/sdoserv.c ****  \param    objLength            Complete size of the object
 862:../SSC/Src/sdoserv.c ****  \param    pData                Pointer to the mailbox buffer
 863:../SSC/Src/sdoserv.c **** 
 864:../SSC/Src/sdoserv.c ****  \brief    This function is called when a SDO response shall be sent
 865:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 866:../SSC/Src/sdoserv.c **** 
 867:../SSC/Src/sdoserv.c **** void SDOS_SdoRes(UINT8 abort, UINT32 objLength, UINT16 MBXMEM *pData)
 868:../SSC/Src/sdoserv.c **** {
 1798              	 .loc 1 868 0
 1799              	 .cfi_startproc
 1800              	 
 1801              	 
 1802 0000 B0B5     	 push {r4,r5,r7,lr}
 1803              	.LCFI20:
 1804              	 .cfi_def_cfa_offset 16
 1805              	 .cfi_offset 4,-16
 1806              	 .cfi_offset 5,-12
 1807              	 .cfi_offset 7,-8
 1808              	 .cfi_offset 14,-4
 1809 0002 88B0     	 sub sp,sp,#32
 1810              	.LCFI21:
 1811              	 .cfi_def_cfa_offset 48
 1812 0004 02AF     	 add r7,sp,#8
 1813              	.LCFI22:
 1814              	 .cfi_def_cfa 7,40
 1815 0006 0346     	 mov r3,r0
 1816 0008 B960     	 str r1,[r7,#8]
 1817 000a 7A60     	 str r2,[r7,#4]
 1818 000c FB73     	 strb r3,[r7,#15]
 869:../SSC/Src/sdoserv.c ****     UINT16 dataSize = 0;
 1819              	 .loc 1 869 0
 1820 000e 0023     	 movs r3,#0
 1821 0010 FB82     	 strh r3,[r7,#22]
 870:../SSC/Src/sdoserv.c **** 
 871:../SSC/Src/sdoserv.c ****     if (bSdoInWork)
 1822              	 .loc 1 871 0
 1823 0012 3A4B     	 ldr r3,.L104
 1824 0014 1B78     	 ldrb r3,[r3]
 1825 0016 002B     	 cmp r3,#0
 1826 0018 6CD0     	 beq .L98
 1827              	.LBB8:
 872:../SSC/Src/sdoserv.c ****     {
 873:../SSC/Src/sdoserv.c ****         /* SDO-Response is expected */
 874:../SSC/Src/sdoserv.c ****         UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
 1828              	 .loc 1 874 0
 1829 001a 394B     	 ldr r3,.L104+4
 1830 001c 1B68     	 ldr r3,[r3]
 1831 001e 1B7A     	 ldrb r3,[r3,#8]
 1832 0020 23F01F03 	 bic r3,r3,#31
 1833 0024 7B75     	 strb r3,[r7,#21]
 875:../SSC/Src/sdoserv.c ****         UINT8 completeAccess = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_CO
 1834              	 .loc 1 875 0
 1835 0026 364B     	 ldr r3,.L104+4
 1836 0028 1B68     	 ldr r3,[r3]
 1837 002a 1B7A     	 ldrb r3,[r3,#8]
 1838 002c 03F01003 	 and r3,r3,#16
 1839 0030 3B75     	 strb r3,[r7,#20]
 876:../SSC/Src/sdoserv.c **** 
 877:../SSC/Src/sdoserv.c ****         if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 1840              	 .loc 1 877 0
 1841 0032 7B7D     	 ldrb r3,[r7,#21]
 1842 0034 402B     	 cmp r3,#64
 1843 0036 4DD1     	 bne .L100
 878:../SSC/Src/sdoserv.c ****         {
 879:../SSC/Src/sdoserv.c ****             /* dataSize contains the available size in one mailbox */
 880:../SSC/Src/sdoserv.c ****             dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
 1844              	 .loc 1 880 0
 1845 0038 324B     	 ldr r3,.L104+8
 1846 003a 1B88     	 ldrh r3,[r3]
 1847 003c 103B     	 subs r3,r3,#16
 1848 003e FB82     	 strh r3,[r7,#22]
 881:../SSC/Src/sdoserv.c ****             if ( dataSize < objLength )
 1849              	 .loc 1 881 0
 1850 0040 FA8A     	 ldrh r2,[r7,#22]
 1851 0042 BB68     	 ldr r3,[r7,#8]
 1852 0044 9A42     	 cmp r2,r3
 1853 0046 1FD2     	 bcs .L101
 882:../SSC/Src/sdoserv.c ****             {
 883:../SSC/Src/sdoserv.c ****                 /* Segmented Upload, the variables for the segmented transfer should be initialized
 884:../SSC/Src/sdoserv.c ****                 bSdoSegFollows         = TRUE;
 1854              	 .loc 1 884 0
 1855 0048 2F4B     	 ldr r3,.L104+12
 1856 004a 0122     	 movs r2,#1
 1857 004c 1A70     	 strb r2,[r3]
 885:../SSC/Src/sdoserv.c ****                 bSdoSegLastToggle     = 1;
 1858              	 .loc 1 885 0
 1859 004e 2F4B     	 ldr r3,.L104+16
 1860 0050 0122     	 movs r2,#1
 1861 0052 1A70     	 strb r2,[r3]
 886:../SSC/Src/sdoserv.c ****                 bSdoSegAccess             = completeAccess;
 1862              	 .loc 1 886 0
 1863 0054 2E4A     	 ldr r2,.L104+20
 1864 0056 3B7D     	 ldrb r3,[r7,#20]
 1865 0058 1370     	 strb r3,[r2]
 887:../SSC/Src/sdoserv.c ****                 nSdoSegCompleteSize    = objLength;
 1866              	 .loc 1 887 0
 1867 005a 2E4A     	 ldr r2,.L104+24
 1868 005c BB68     	 ldr r3,[r7,#8]
 1869 005e 1360     	 str r3,[r2]
 888:../SSC/Src/sdoserv.c ****                 nSdoSegService            = SDOSERVICE_UPLOADSEGMENTREQ;
 1870              	 .loc 1 888 0
 1871 0060 2D4B     	 ldr r3,.L104+28
 1872 0062 6022     	 movs r2,#96
 1873 0064 1A70     	 strb r2,[r3]
 889:../SSC/Src/sdoserv.c ****                 pSdoSegData                = (UINT16 VARMEM *) pData;
 1874              	 .loc 1 889 0
 1875 0066 2D4A     	 ldr r2,.L104+32
 1876 0068 7B68     	 ldr r3,[r7,#4]
 1877 006a 1360     	 str r3,[r2]
 890:../SSC/Src/sdoserv.c ****                 /* the first segment shall be copied */
 891:../SSC/Src/sdoserv.c ****                 MBXMEMCPY(((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSiz
 1878              	 .loc 1 891 0
 1879 006c 244B     	 ldr r3,.L104+4
 1880 006e 1B68     	 ldr r3,[r3]
 1881 0070 03F11002 	 add r2,r3,#16
 1882 0074 FB8A     	 ldrh r3,[r7,#22]
 1883 0076 1046     	 mov r0,r2
 1884 0078 7968     	 ldr r1,[r7,#4]
 1885 007a 1A46     	 mov r2,r3
 1886 007c FFF7FEFF 	 bl memcpy
 892:../SSC/Src/sdoserv.c ****                 nSdoSegBytesToHandle = dataSize;
 1887              	 .loc 1 892 0
 1888 0080 FB8A     	 ldrh r3,[r7,#22]
 1889 0082 274A     	 ldr r2,.L104+36
 1890 0084 1360     	 str r3,[r2]
 1891 0086 25E0     	 b .L100
 1892              	.L101:
 893:../SSC/Src/sdoserv.c ****             }
 894:../SSC/Src/sdoserv.c ****             else
 895:../SSC/Src/sdoserv.c ****             if ( (objLength <= 4) && (objLength > 0) )
 1893              	 .loc 1 895 0
 1894 0088 BB68     	 ldr r3,[r7,#8]
 1895 008a 042B     	 cmp r3,#4
 1896 008c 13D8     	 bhi .L102
 1897              	 .loc 1 895 0 is_stmt 0 discriminator 1
 1898 008e BB68     	 ldr r3,[r7,#8]
 1899 0090 002B     	 cmp r3,#0
 1900 0092 10D0     	 beq .L102
 896:../SSC/Src/sdoserv.c ****             {
 897:../SSC/Src/sdoserv.c ****                 /* Expedited response */
 898:../SSC/Src/sdoserv.c ****                 if ( pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data )
 1901              	 .loc 1 898 0 is_stmt 1
 1902 0094 1A4B     	 ldr r3,.L104+4
 1903 0096 1B68     	 ldr r3,[r3]
 1904 0098 03F10C02 	 add r2,r3,#12
 1905 009c 7B68     	 ldr r3,[r7,#4]
 1906 009e 9A42     	 cmp r2,r3
 1907 00a0 08D0     	 beq .L103
 899:../SSC/Src/sdoserv.c ****                 {
 900:../SSC/Src/sdoserv.c ****                     /* the data is not in the response buffer yet, it shall be copied */
 901:../SSC/Src/sdoserv.c ****                     MBXMEMCPY(((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data, pData, objL
 1908              	 .loc 1 901 0
 1909 00a2 174B     	 ldr r3,.L104+4
 1910 00a4 1B68     	 ldr r3,[r3]
 1911 00a6 0C33     	 adds r3,r3,#12
 1912 00a8 1846     	 mov r0,r3
 1913 00aa 7968     	 ldr r1,[r7,#4]
 1914 00ac BA68     	 ldr r2,[r7,#8]
 1915 00ae FFF7FEFF 	 bl memcpy
 898:../SSC/Src/sdoserv.c ****                 {
 1916              	 .loc 1 898 0
 1917 00b2 0FE0     	 b .L100
 1918              	.L103:
 1919 00b4 0EE0     	 b .L100
 1920              	.L102:
 902:../SSC/Src/sdoserv.c ****                 }
 903:../SSC/Src/sdoserv.c ****             }
 904:../SSC/Src/sdoserv.c ****             else
 905:../SSC/Src/sdoserv.c ****             {
 906:../SSC/Src/sdoserv.c ****                 /* Normal response */
 907:../SSC/Src/sdoserv.c ****                 if ( pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data )
 1921              	 .loc 1 907 0
 1922 00b6 124B     	 ldr r3,.L104+4
 1923 00b8 1B68     	 ldr r3,[r3]
 1924 00ba 03F11002 	 add r2,r3,#16
 1925 00be 7B68     	 ldr r3,[r7,#4]
 1926 00c0 9A42     	 cmp r2,r3
 1927 00c2 07D0     	 beq .L100
 908:../SSC/Src/sdoserv.c ****                 {
 909:../SSC/Src/sdoserv.c ****                     /* the data is not in the response buffer yet, it shall be copied */
 910:../SSC/Src/sdoserv.c ****                     MBXMEMCPY(((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, obj
 1928              	 .loc 1 910 0
 1929 00c4 0E4B     	 ldr r3,.L104+4
 1930 00c6 1B68     	 ldr r3,[r3]
 1931 00c8 1033     	 adds r3,r3,#16
 1932 00ca 1846     	 mov r0,r3
 1933 00cc 7968     	 ldr r1,[r7,#4]
 1934 00ce BA68     	 ldr r2,[r7,#8]
 1935 00d0 FFF7FEFF 	 bl memcpy
 1936              	.L100:
 911:../SSC/Src/sdoserv.c ****                 }
 912:../SSC/Src/sdoserv.c ****             }
 913:../SSC/Src/sdoserv.c ****         }
 914:../SSC/Src/sdoserv.c **** 
 915:../SSC/Src/sdoserv.c ****         /* SDO access is finished, send the response */
 916:../SSC/Src/sdoserv.c ****         bSdoInWork = FALSE;
 1937              	 .loc 1 916 0
 1938 00d4 094B     	 ldr r3,.L104
 1939 00d6 0022     	 movs r2,#0
 1940 00d8 1A70     	 strb r2,[r3]
 917:../SSC/Src/sdoserv.c ****         SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
 1941              	 .loc 1 917 0
 1942 00da 094B     	 ldr r3,.L104+4
 1943 00dc 1B68     	 ldr r3,[r3]
 1944 00de F87B     	 ldrb r0,[r7,#15]
 1945 00e0 797D     	 ldrb r1,[r7,#21]
 1946 00e2 3D7D     	 ldrb r5,[r7,#20]
 1947 00e4 FC8A     	 ldrh r4,[r7,#22]
 1948 00e6 BA68     	 ldr r2,[r7,#8]
 1949 00e8 0092     	 str r2,[sp]
 1950 00ea 0193     	 str r3,[sp,#4]
 1951 00ec 2A46     	 mov r2,r5
 1952 00ee 2346     	 mov r3,r4
 1953 00f0 FFF7FEFF 	 bl SdoRes
 1954              	.L98:
 1955              	.LBE8:
 918:../SSC/Src/sdoserv.c ****     }
 919:../SSC/Src/sdoserv.c **** }
 1956              	 .loc 1 919 0
 1957 00f4 1837     	 adds r7,r7,#24
 1958              	.LCFI23:
 1959              	 .cfi_def_cfa_offset 16
 1960 00f6 BD46     	 mov sp,r7
 1961              	.LCFI24:
 1962              	 .cfi_def_cfa_register 13
 1963              	 
 1964 00f8 B0BD     	 pop {r4,r5,r7,pc}
 1965              	.L105:
 1966 00fa 00BF     	 .align 2
 1967              	.L104:
 1968 00fc 00000000 	 .word bSdoInWork
 1969 0100 00000000 	 .word pSdoResStored
 1970 0104 00000000 	 .word u16SendMbxSize
 1971 0108 00000000 	 .word bSdoSegFollows
 1972 010c 00000000 	 .word bSdoSegLastToggle
 1973 0110 00000000 	 .word bSdoSegAccess
 1974 0114 00000000 	 .word nSdoSegCompleteSize
 1975 0118 00000000 	 .word nSdoSegService
 1976 011c 00000000 	 .word pSdoSegData
 1977 0120 00000000 	 .word nSdoSegBytesToHandle
 1978              	 .cfi_endproc
 1979              	.LFE176:
 1981              	 .section .text.SDOS_SdoInfoInd,"ax",%progbits
 1982              	 .align 2
 1983              	 .global SDOS_SdoInfoInd
 1984              	 .thumb
 1985              	 .thumb_func
 1987              	SDOS_SdoInfoInd:
 1988              	.LFB177:
 920:../SSC/Src/sdoserv.c **** 
 921:../SSC/Src/sdoserv.c **** 
 922:../SSC/Src/sdoserv.c **** /////////////////////////////////////////////////////////////////////////////////////////
 923:../SSC/Src/sdoserv.c **** /**
 924:../SSC/Src/sdoserv.c ****  \param    pSdoInfoInd      Pointer to the received mailbox data from the master.
 925:../SSC/Src/sdoserv.c **** 
 926:../SSC/Src/sdoserv.c ****  \return    Indicates if an error occurred while the operation ( good = 0 ).
 927:../SSC/Src/sdoserv.c **** 
 928:../SSC/Src/sdoserv.c ****  \brief    This function is called when a SDO-Info request service
 929:../SSC/Src/sdoserv.c ****             is received from the master and calls depending from
 930:../SSC/Src/sdoserv.c ****             the opcode the concerning function.
 931:../SSC/Src/sdoserv.c **** *////////////////////////////////////////////////////////////////////////////////////////
 932:../SSC/Src/sdoserv.c **** 
 933:../SSC/Src/sdoserv.c **** UINT8 SDOS_SdoInfoInd( TSDOINFORMATION MBXMEM *pSdoInfoInd )
 934:../SSC/Src/sdoserv.c **** {
 1989              	 .loc 1 934 0
 1990              	 .cfi_startproc
 1991              	 
 1992              	 
 1993 0000 90B5     	 push {r4,r7,lr}
 1994              	.LCFI25:
 1995              	 .cfi_def_cfa_offset 12
 1996              	 .cfi_offset 4,-12
 1997              	 .cfi_offset 7,-8
 1998              	 .cfi_offset 14,-4
 1999 0002 8FB0     	 sub sp,sp,#60
 2000              	.LCFI26:
 2001              	 .cfi_def_cfa_offset 72
 2002 0004 02AF     	 add r7,sp,#8
 2003              	.LCFI27:
 2004              	 .cfi_def_cfa 7,64
 2005 0006 7860     	 str r0,[r7,#4]
 935:../SSC/Src/sdoserv.c ****     UINT8 abort = 0;
 2006              	 .loc 1 935 0
 2007 0008 0023     	 movs r3,#0
 2008 000a FB73     	 strb r3,[r7,#15]
 936:../SSC/Src/sdoserv.c ****     /* the variable opCode contains the requested SDO Information type */
 937:../SSC/Src/sdoserv.c ****     UINT8 opCode = (UINT8) ((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OP
 2009              	 .loc 1 937 0
 2010 000c 7B68     	 ldr r3,[r7,#4]
 2011 000e 1B89     	 ldrh r3,[r3,#8]
 2012 0010 DBB2     	 uxtb r3,r3
 2013 0012 03F07F03 	 and r3,r3,#127
 2014 0016 87F82130 	 strb r3,[r7,#33]
 938:../SSC/Src/sdoserv.c ****     OBJCONST TOBJECT OBJMEM * pObjEntry;
 939:../SSC/Src/sdoserv.c ****     UINT16 index;
 940:../SSC/Src/sdoserv.c ****     UINT8 flags = COE_SERVICE;
 2015              	 .loc 1 940 0
 2016 001a 0223     	 movs r3,#2
 2017 001c 87F82F30 	 strb r3,[r7,#47]
 941:../SSC/Src/sdoserv.c **** 
 942:../SSC/Src/sdoserv.c ****     /* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
 943:../SSC/Src/sdoserv.c ****        great enough for the service header of the requested SDO Information type */
 944:../SSC/Src/sdoserv.c ****     if ( opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q )
 2018              	 .loc 1 944 0
 2019 0020 97F82130 	 ldrb r3,[r7,#33]
 2020 0024 052B     	 cmp r3,#5
 2021 0026 05D1     	 bne .L107
 945:../SSC/Src/sdoserv.c ****     {
 946:../SSC/Src/sdoserv.c ****         if ( pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOENTRYREQSTRUCT )
 2022              	 .loc 1 946 0
 2023 0028 7B68     	 ldr r3,[r7,#4]
 2024 002a 1B88     	 ldrh r3,[r3]
 2025 002c 092B     	 cmp r3,#9
 2026 002e 07D8     	 bhi .L108
 947:../SSC/Src/sdoserv.c ****             return MBXERR_SIZETOOSHORT;
 2027              	 .loc 1 947 0
 2028 0030 0623     	 movs r3,#6
 2029 0032 D9E1     	 b .L137
 2030              	.L107:
 948:../SSC/Src/sdoserv.c ****     }
 949:../SSC/Src/sdoserv.c ****     else
 950:../SSC/Src/sdoserv.c ****     {
 951:../SSC/Src/sdoserv.c ****         if ( pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOLISTSTRUCT )
 2031              	 .loc 1 951 0
 2032 0034 7B68     	 ldr r3,[r7,#4]
 2033 0036 1B88     	 ldrh r3,[r3]
 2034 0038 072B     	 cmp r3,#7
 2035 003a 01D8     	 bhi .L108
 952:../SSC/Src/sdoserv.c ****             return MBXERR_SIZETOOSHORT;
 2036              	 .loc 1 952 0
 2037 003c 0623     	 movs r3,#6
 2038 003e D3E1     	 b .L137
 2039              	.L108:
 953:../SSC/Src/sdoserv.c ****     }
 954:../SSC/Src/sdoserv.c **** 
 955:../SSC/Src/sdoserv.c ****     switch ( opCode )
 2040              	 .loc 1 955 0
 2041 0040 97F82130 	 ldrb r3,[r7,#33]
 2042 0044 032B     	 cmp r3,#3
 2043 0046 00F0CA80 	 beq .L111
 2044 004a 052B     	 cmp r3,#5
 2045 004c 00F0C780 	 beq .L111
 2046 0050 012B     	 cmp r3,#1
 2047 0052 40F09981 	 bne .L138
 956:../SSC/Src/sdoserv.c ****     {
 957:../SSC/Src/sdoserv.c ****     case SDOINFOSERVICE_OBJDICTIONARYLIST_Q:
 958:../SSC/Src/sdoserv.c ****         /* an object list is requested, check if the list type is supported */
 959:../SSC/Src/sdoserv.c ****         if ( SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType) <= INFO_LIST_TYPE_MAX )
 2048              	 .loc 1 959 0
 2049 0056 7B68     	 ldr r3,[r7,#4]
 2050 0058 9B89     	 ldrh r3,[r3,#12]
 2051 005a 052B     	 cmp r3,#5
 2052 005c 00F2BE80 	 bhi .L113
 2053              	.LBB9:
 960:../SSC/Src/sdoserv.c ****         {
 961:../SSC/Src/sdoserv.c ****             UINT16 size = 0;
 2054              	 .loc 1 961 0
 2055 0060 0023     	 movs r3,#0
 2056 0062 BB85     	 strh r3,[r7,#44]
 962:../SSC/Src/sdoserv.c ****             /* the variable listType contains the requested listType */
 963:../SSC/Src/sdoserv.c ****             UINT8 listType = (UINT8) SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType);
 2057              	 .loc 1 963 0
 2058 0064 7B68     	 ldr r3,[r7,#4]
 2059 0066 9B89     	 ldrh r3,[r3,#12]
 2060 0068 87F82030 	 strb r3,[r7,#32]
 964:../SSC/Src/sdoserv.c **** 
 965:../SSC/Src/sdoserv.c ****             /* the SDO Information Header has to be stored because this function will be
 966:../SSC/Src/sdoserv.c ****                called again if the response could not be sent with one mailbox service, the
 967:../SSC/Src/sdoserv.c ****                variable nSdoInfoFragmentsLeft is 0 zero for the first call and unequal 0
 968:../SSC/Src/sdoserv.c ****                for the following calls */
 969:../SSC/Src/sdoserv.c ****             MBXMEMCPY(aSdoInfoHeader, pSdoInfoInd, SDO_INFO_HEADER_BYTE_SIZE);
 2061              	 .loc 1 969 0
 2062 006c A848     	 ldr r0,.L139
 2063 006e 7968     	 ldr r1,[r7,#4]
 2064 0070 0E22     	 movs r2,#14
 2065 0072 FFF7FEFF 	 bl memcpy
 970:../SSC/Src/sdoserv.c ****             if ( listType-- == 0 )
 2066              	 .loc 1 970 0
 2067 0076 97F82030 	 ldrb r3,[r7,#32]
 2068 007a 5A1E     	 subs r2,r3,#1
 2069 007c 87F82020 	 strb r2,[r7,#32]
 2070 0080 002B     	 cmp r3,#0
 2071 0082 22D1     	 bne .L114
 2072              	.LBB10:
 971:../SSC/Src/sdoserv.c ****             {
 972:../SSC/Src/sdoserv.c ****                 /* List-Type 0: length of the lists */
 973:../SSC/Src/sdoserv.c ****                 UINT8 i;
 974:../SSC/Src/sdoserv.c **** 
 975:../SSC/Src/sdoserv.c ****                 /* the needed mailbox size for List-Type 0 response is just 24 bytes, the mailbox h
 976:../SSC/Src/sdoserv.c ****                    to be at least 24 bytes to support the SDO Information service */
 977:../SSC/Src/sdoserv.c ****                 nSdoInfoFragmentsLeft = 0;
 2073              	 .loc 1 977 0
 2074 0084 A34B     	 ldr r3,.L139+4
 2075 0086 0022     	 movs r2,#0
 2076 0088 1A80     	 strh r2,[r3]
 978:../SSC/Src/sdoserv.c ****                 for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
 2077              	 .loc 1 978 0
 2078 008a 0023     	 movs r3,#0
 2079 008c 87F82B30 	 strb r3,[r7,#43]
 2080 0090 14E0     	 b .L115
 2081              	.L116:
 2082              	.LBB11:
 979:../SSC/Src/sdoserv.c ****                 {
 980:../SSC/Src/sdoserv.c ****                     UINT16 n = OBJ_GetNoOfObjects(i);
 2083              	 .loc 1 980 0 discriminator 3
 2084 0092 97F82B30 	 ldrb r3,[r7,#43]
 2085 0096 1846     	 mov r0,r3
 2086 0098 FFF7FEFF 	 bl OBJ_GetNoOfObjects
 2087 009c 0346     	 mov r3,r0
 2088 009e FB83     	 strh r3,[r7,#30]
 981:../SSC/Src/sdoserv.c **** 
 982:../SSC/Src/sdoserv.c ****                     /* copy the number of objects of the list type in the SDO Information response 
 983:../SSC/Src/sdoserv.c ****                     ((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[(SIZEOF_SDOINFOLISTSTRUCT>>1)+i] = 
 2089              	 .loc 1 983 0 discriminator 3
 2090 00a0 7B68     	 ldr r3,[r7,#4]
 2091 00a2 9A1D     	 adds r2,r3,#6
 2092 00a4 97F82B30 	 ldrb r3,[r7,#43]
 2093 00a8 0433     	 adds r3,r3,#4
 2094 00aa 5B00     	 lsls r3,r3,#1
 2095 00ac 1344     	 add r3,r3,r2
 2096 00ae FA8B     	 ldrh r2,[r7,#30]
 2097 00b0 1A80     	 strh r2,[r3]
 2098              	.LBE11:
 978:../SSC/Src/sdoserv.c ****                 {
 2099              	 .loc 1 978 0 discriminator 3
 2100 00b2 97F82B30 	 ldrb r3,[r7,#43]
 2101 00b6 0133     	 adds r3,r3,#1
 2102 00b8 87F82B30 	 strb r3,[r7,#43]
 2103              	.L115:
 978:../SSC/Src/sdoserv.c ****                 {
 2104              	 .loc 1 978 0 is_stmt 0 discriminator 1
 2105 00bc 97F82B30 	 ldrb r3,[r7,#43]
 2106 00c0 042B     	 cmp r3,#4
 2107 00c2 E6D9     	 bls .L116
 984:../SSC/Src/sdoserv.c ****                 }
 985:../SSC/Src/sdoserv.c **** 
 986:../SSC/Src/sdoserv.c ****                 /* size of the mailbox service response */
 987:../SSC/Src/sdoserv.c ****                 size = (INFO_LIST_TYPE_MAX << 1) + SIZEOF_SDOINFOLISTSTRUCT;
 2108              	 .loc 1 987 0 is_stmt 1
 2109 00c4 1223     	 movs r3,#18
 2110 00c6 BB85     	 strh r3,[r7,#44]
 2111              	.LBE10:
 2112 00c8 5AE0     	 b .L117
 2113              	.L114:
 2114              	.LBB12:
 988:../SSC/Src/sdoserv.c ****             }
 989:../SSC/Src/sdoserv.c ****             else
 990:../SSC/Src/sdoserv.c ****             {
 991:../SSC/Src/sdoserv.c ****                 /* object list with indexes is requested */
 992:../SSC/Src/sdoserv.c ****                 UINT16 MBXMEM * pData;
 993:../SSC/Src/sdoserv.c ****                 UINT16 n = 0;
 2115              	 .loc 1 993 0
 2116 00ca 0023     	 movs r3,#0
 2117 00cc BB83     	 strh r3,[r7,#28]
 994:../SSC/Src/sdoserv.c **** 
 995:../SSC/Src/sdoserv.c ****                 if ( nSdoInfoFragmentsLeft )
 2118              	 .loc 1 995 0
 2119 00ce 914B     	 ldr r3,.L139+4
 2120 00d0 1B88     	 ldrh r3,[r3]
 2121 00d2 002B     	 cmp r3,#0
 2122 00d4 11D0     	 beq .L118
 996:../SSC/Src/sdoserv.c ****                 {
 997:../SSC/Src/sdoserv.c ****                     /* the next fragment of the SDO Information response shall be sent */
 998:../SSC/Src/sdoserv.c ****                     /* initialize size with the maximum size fits into one mailbox service */
 999:../SSC/Src/sdoserv.c ****                     {
1000:../SSC/Src/sdoserv.c ****                         size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
 2123              	 .loc 1 1000 0
 2124 00d6 904B     	 ldr r3,.L139+8
 2125 00d8 1B88     	 ldrh r3,[r3]
 2126 00da 0C3B     	 subs r3,r3,#12
 2127 00dc BB85     	 strh r3,[r7,#44]
1001:../SSC/Src/sdoserv.c ****                     }
1002:../SSC/Src/sdoserv.c ****                     /* initialize pData with the pointer where the fragment has to be copied */
1003:../SSC/Src/sdoserv.c ****                     pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFO>>1];
 2128              	 .loc 1 1003 0
 2129 00de 7B68     	 ldr r3,[r7,#4]
 2130 00e0 0633     	 adds r3,r3,#6
 2131 00e2 0633     	 adds r3,r3,#6
 2132 00e4 7B62     	 str r3,[r7,#36]
1004:../SSC/Src/sdoserv.c ****                     /* initialize index with the next index to be sent */
1005:../SSC/Src/sdoserv.c ****                     index = nSdoInfoIndex;
 2133              	 .loc 1 1005 0
 2134 00e6 8D4B     	 ldr r3,.L139+12
 2135 00e8 1B88     	 ldrh r3,[r3]
 2136 00ea BB81     	 strh r3,[r7,#12]
1006:../SSC/Src/sdoserv.c ****                     /* decrement the number of fragments to be sent */
1007:../SSC/Src/sdoserv.c ****                     nSdoInfoFragmentsLeft--;
 2137              	 .loc 1 1007 0
 2138 00ec 894B     	 ldr r3,.L139+4
 2139 00ee 1B88     	 ldrh r3,[r3]
 2140 00f0 013B     	 subs r3,r3,#1
 2141 00f2 9AB2     	 uxth r2,r3
 2142 00f4 874B     	 ldr r3,.L139+4
 2143 00f6 1A80     	 strh r2,[r3]
 2144 00f8 2AE0     	 b .L119
 2145              	.L118:
1008:../SSC/Src/sdoserv.c ****                 }
1009:../SSC/Src/sdoserv.c ****                 else
1010:../SSC/Src/sdoserv.c ****                 {
1011:../SSC/Src/sdoserv.c ****                     /* the first fragment of the SDO Information response has to be sent */
1012:../SSC/Src/sdoserv.c ****                     /* get the number of objects of the requested object list */
1013:../SSC/Src/sdoserv.c ****                     n = OBJ_GetNoOfObjects(listType);
 2146              	 .loc 1 1013 0
 2147 00fa 97F82030 	 ldrb r3,[r7,#32]
 2148 00fe 1846     	 mov r0,r3
 2149 0100 FFF7FEFF 	 bl OBJ_GetNoOfObjects
 2150 0104 0346     	 mov r3,r0
 2151 0106 BB83     	 strh r3,[r7,#28]
1014:../SSC/Src/sdoserv.c ****                     /* we start with index 0x1000 */
1015:../SSC/Src/sdoserv.c ****                     index = 0x1000;
 2152              	 .loc 1 1015 0
 2153 0108 4FF48053 	 mov r3,#4096
 2154 010c BB81     	 strh r3,[r7,#12]
1016:../SSC/Src/sdoserv.c ****                     /* initialize size with the maximum size fits into one mailbox service */
1017:../SSC/Src/sdoserv.c ****                     {
1018:../SSC/Src/sdoserv.c ****                         size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
 2155              	 .loc 1 1018 0
 2156 010e 824B     	 ldr r3,.L139+8
 2157 0110 1B88     	 ldrh r3,[r3]
 2158 0112 0E3B     	 subs r3,r3,#14
 2159 0114 BB85     	 strh r3,[r7,#44]
1019:../SSC/Src/sdoserv.c ****                     }
1020:../SSC/Src/sdoserv.c ****                     /* initialize pData with the pointer where the fragment has to be copied */
1021:../SSC/Src/sdoserv.c ****                     pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFOLISTSTRUCT>>
 2160              	 .loc 1 1021 0
 2161 0116 7B68     	 ldr r3,[r7,#4]
 2162 0118 0633     	 adds r3,r3,#6
 2163 011a 0833     	 adds r3,r3,#8
 2164 011c 7B62     	 str r3,[r7,#36]
1022:../SSC/Src/sdoserv.c ****                     /*Check if List need to be send in fragments*/
1023:../SSC/Src/sdoserv.c ****                     if( (n<<1) > size)
 2165              	 .loc 1 1023 0
 2166 011e BB8B     	 ldrh r3,[r7,#28]
 2167 0120 5A00     	 lsls r2,r3,#1
 2168 0122 BB8D     	 ldrh r3,[r7,#44]
 2169 0124 9A42     	 cmp r2,r3
 2170 0126 10DD     	 ble .L120
 2171              	.LBB13:
1024:../SSC/Src/sdoserv.c ****                     {
1025:../SSC/Src/sdoserv.c ****                         /*number of Bytes to transmit don't fit into one mailbox datagram*/
1026:../SSC/Src/sdoserv.c **** 
1027:../SSC/Src/sdoserv.c ****                         /*calculate number of fragments which need to be send
1028:../SSC/Src/sdoserv.c ****                         total number of bytes - bytes which will be transmitted with the current re
1029:../SSC/Src/sdoserv.c ****                         */
1030:../SSC/Src/sdoserv.c ****                         UINT16 Fragsize = size + 2;
 2172              	 .loc 1 1030 0
 2173 0128 BB8D     	 ldrh r3,[r7,#44]
 2174 012a 0233     	 adds r3,r3,#2
 2175 012c 7B83     	 strh r3,[r7,#26]
1031:../SSC/Src/sdoserv.c ****                         nSdoInfoFragmentsLeft = (((n<<1)-size + (Fragsize-1)) /Fragsize);
 2176              	 .loc 1 1031 0
 2177 012e BB8B     	 ldrh r3,[r7,#28]
 2178 0130 5A00     	 lsls r2,r3,#1
 2179 0132 BB8D     	 ldrh r3,[r7,#44]
 2180 0134 D21A     	 subs r2,r2,r3
 2181 0136 7B8B     	 ldrh r3,[r7,#26]
 2182 0138 013B     	 subs r3,r3,#1
 2183 013a 1A44     	 add r2,r2,r3
 2184 013c 7B8B     	 ldrh r3,[r7,#26]
 2185 013e 92FBF3F3 	 sdiv r3,r2,r3
 2186 0142 9AB2     	 uxth r2,r3
 2187 0144 734B     	 ldr r3,.L139+4
 2188 0146 1A80     	 strh r2,[r3]
 2189              	.LBE13:
 2190 0148 02E0     	 b .L119
 2191              	.L120:
1032:../SSC/Src/sdoserv.c ****                     }
1033:../SSC/Src/sdoserv.c ****                     else
1034:../SSC/Src/sdoserv.c ****                     {
1035:../SSC/Src/sdoserv.c ****                         nSdoInfoFragmentsLeft = 0;
 2192              	 .loc 1 1035 0
 2193 014a 724B     	 ldr r3,.L139+4
 2194 014c 0022     	 movs r2,#0
 2195 014e 1A80     	 strh r2,[r3]
 2196              	.L119:
1036:../SSC/Src/sdoserv.c ****                     }
1037:../SSC/Src/sdoserv.c ****                 }
1038:../SSC/Src/sdoserv.c **** 
1039:../SSC/Src/sdoserv.c ****                 /* get the next part of the requested object list */
1040:../SSC/Src/sdoserv.c ****                 size = OBJ_GetObjectList(listType, &index, size, pData,&abort);
 2197              	 .loc 1 1040 0
 2198 0150 97F82030 	 ldrb r3,[r7,#32]
 2199 0154 98B2     	 uxth r0,r3
 2200 0156 07F10C01 	 add r1,r7,#12
 2201 015a BA8D     	 ldrh r2,[r7,#44]
 2202 015c 07F10F03 	 add r3,r7,#15
 2203 0160 0093     	 str r3,[sp]
 2204 0162 7B6A     	 ldr r3,[r7,#36]
 2205 0164 FFF7FEFF 	 bl OBJ_GetObjectList
 2206 0168 0346     	 mov r3,r0
 2207 016a BB85     	 strh r3,[r7,#44]
1041:../SSC/Src/sdoserv.c **** 
1042:../SSC/Src/sdoserv.c ****                 /* store index for next fragment */
1043:../SSC/Src/sdoserv.c ****                 nSdoInfoIndex = index;
 2208              	 .loc 1 1043 0
 2209 016c BA89     	 ldrh r2,[r7,#12]
 2210 016e 6B4B     	 ldr r3,.L139+12
 2211 0170 1A80     	 strh r2,[r3]
1044:../SSC/Src/sdoserv.c ****                 /* size contains before the instruction the size still available in the mailbox buf
1045:../SSC/Src/sdoserv.c ****                     and shall contain the size of the mailbox response data after the next instruct
1046:../SSC/Src/sdoserv.c ****                 {
1047:../SSC/Src/sdoserv.c ****                     size = u16SendMbxSize - size - MBX_HEADER_SIZE;
 2212              	 .loc 1 1047 0
 2213 0172 694B     	 ldr r3,.L139+8
 2214 0174 1A88     	 ldrh r2,[r3]
 2215 0176 BB8D     	 ldrh r3,[r7,#44]
 2216 0178 D31A     	 subs r3,r2,r3
 2217 017a 9BB2     	 uxth r3,r3
 2218 017c 063B     	 subs r3,r3,#6
 2219 017e BB85     	 strh r3,[r7,#44]
 2220              	.L117:
 2221              	.LBE12:
1048:../SSC/Src/sdoserv.c ****                 }
1049:../SSC/Src/sdoserv.c ****             }
1050:../SSC/Src/sdoserv.c **** 
1051:../SSC/Src/sdoserv.c ****             /* size of the mailbox response data */
1052:../SSC/Src/sdoserv.c ****             pSdoInfoInd->MbxHeader.Length    = size;
 2222              	 .loc 1 1052 0
 2223 0180 7B68     	 ldr r3,[r7,#4]
 2224 0182 BA8D     	 ldrh r2,[r7,#44]
 2225 0184 1A80     	 strh r2,[r3]
1053:../SSC/Src/sdoserv.c **** 
1054:../SSC/Src/sdoserv.c ****             if(abort == 0)
 2226              	 .loc 1 1054 0
 2227 0186 FB7B     	 ldrb r3,[r7,#15]
 2228 0188 002B     	 cmp r3,#0
 2229 018a 27D1     	 bne .L113
1055:../SSC/Src/sdoserv.c ****             {
1056:../SSC/Src/sdoserv.c ****              pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
 2230              	 .loc 1 1056 0
 2231 018c 7B68     	 ldr r3,[r7,#4]
 2232 018e 1B89     	 ldrh r3,[r3,#8]
 2233 0190 23F07F03 	 bic r3,r3,#127
 2234 0194 9AB2     	 uxth r2,r3
 2235 0196 7B68     	 ldr r3,[r7,#4]
 2236 0198 1A81     	 strh r2,[r3,#8]
1057:../SSC/Src/sdoserv.c ****              pSdoInfoInd->SdoHeader.InfoHead |= (UINT16) (SDOINFOSERVICE_OBJDICTIONARYLIST_S << INF
 2237              	 .loc 1 1057 0
 2238 019a 7B68     	 ldr r3,[r7,#4]
 2239 019c 1B89     	 ldrh r3,[r3,#8]
 2240 019e 43F00203 	 orr r3,r3,#2
 2241 01a2 9AB2     	 uxth r2,r3
 2242 01a4 7B68     	 ldr r3,[r7,#4]
 2243 01a6 1A81     	 strh r2,[r3,#8]
1058:../SSC/Src/sdoserv.c ****                 /* number of fragments still has to be sent */
1059:../SSC/Src/sdoserv.c ****                 pSdoInfoInd->SdoHeader.FragmentsLeft             = SWAPWORD(nSdoInfoFragmentsLeft);
 2244              	 .loc 1 1059 0
 2245 01a8 5A4B     	 ldr r3,.L139+4
 2246 01aa 1A88     	 ldrh r2,[r3]
 2247 01ac 7B68     	 ldr r3,[r7,#4]
 2248 01ae 5A81     	 strh r2,[r3,#10]
1060:../SSC/Src/sdoserv.c **** 
1061:../SSC/Src/sdoserv.c ****                 if (nSdoInfoFragmentsLeft)
 2249              	 .loc 1 1061 0
 2250 01b0 584B     	 ldr r3,.L139+4
 2251 01b2 1B88     	 ldrh r3,[r3]
 2252 01b4 002B     	 cmp r3,#0
 2253 01b6 11D0     	 beq .L113
1062:../SSC/Src/sdoserv.c ****                 {
1063:../SSC/Src/sdoserv.c ****                     /* there still are fragments to be sent,
1064:../SSC/Src/sdoserv.c ****                        the InComplete flag in the SDO Information response has to be sent */
1065:../SSC/Src/sdoserv.c ****                     pSdoInfoInd->SdoHeader.InfoHead &= ~ INFOHEADER_INCOMPLETE_MASK;
 2254              	 .loc 1 1065 0
 2255 01b8 7B68     	 ldr r3,[r7,#4]
 2256 01ba 1B89     	 ldrh r3,[r3,#8]
 2257 01bc 23F08003 	 bic r3,r3,#128
 2258 01c0 9AB2     	 uxth r2,r3
 2259 01c2 7B68     	 ldr r3,[r7,#4]
 2260 01c4 1A81     	 strh r2,[r3,#8]
1066:../SSC/Src/sdoserv.c ****                     pSdoInfoInd->SdoHeader.InfoHead |= (UINT16) (SDOINFOSERVICE_INCOMPLETE << INFOH
 2261              	 .loc 1 1066 0
 2262 01c6 7B68     	 ldr r3,[r7,#4]
 2263 01c8 1B89     	 ldrh r3,[r3,#8]
 2264 01ca 43F08003 	 orr r3,r3,#128
 2265 01ce 9AB2     	 uxth r2,r3
 2266 01d0 7B68     	 ldr r3,[r7,#4]
 2267 01d2 1A81     	 strh r2,[r3,#8]
1067:../SSC/Src/sdoserv.c ****                     /* the FRAGMENTS_FOLLOW flag has to be set for the function MBX_MailboxSendReq 
1068:../SSC/Src/sdoserv.c ****                        indicate the mailbox handler that still fragments has to be sent so that thi
1069:../SSC/Src/sdoserv.c ****                         function shall be called again from COE_ContinueInd when the actual mailbox
1070:../SSC/Src/sdoserv.c ****                         was sent */
1071:../SSC/Src/sdoserv.c ****                     flags = FRAGMENTS_FOLLOW | COE_SERVICE;
 2268              	 .loc 1 1071 0
 2269 01d4 8223     	 movs r3,#130
 2270 01d6 87F82F30 	 strb r3,[r7,#47]
 2271              	.LBE9:
1072:../SSC/Src/sdoserv.c ****                 }
1073:../SSC/Src/sdoserv.c ****             }
1074:../SSC/Src/sdoserv.c ****         }
1075:../SSC/Src/sdoserv.c ****         break;
 2272              	 .loc 1 1075 0
 2273 01da D7E0     	 b .L121
 2274              	.L113:
 2275 01dc D6E0     	 b .L121
 2276              	.L111:
1076:../SSC/Src/sdoserv.c **** 
1077:../SSC/Src/sdoserv.c ****     case SDOINFOSERVICE_OBJDESCRIPTION_Q:
1078:../SSC/Src/sdoserv.c ****     case SDOINFOSERVICE_ENTRYDESCRIPTION_Q:
1079:../SSC/Src/sdoserv.c ****         /* get the requested index */
1080:../SSC/Src/sdoserv.c ****         index = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Index);
 2277              	 .loc 1 1080 0
 2278 01de 7B68     	 ldr r3,[r7,#4]
 2279 01e0 9B89     	 ldrh r3,[r3,#12]
 2280 01e2 BB81     	 strh r3,[r7,#12]
1081:../SSC/Src/sdoserv.c ****         if(index < 0x1000)
 2281              	 .loc 1 1081 0
 2282 01e4 BB89     	 ldrh r3,[r7,#12]
 2283 01e6 B3F5805F 	 cmp r3,#4096
 2284 01ea 02D2     	 bcs .L122
1082:../SSC/Src/sdoserv.c ****         {
1083:../SSC/Src/sdoserv.c ****             /*SDO Info access is only allowed for objects >= 0x1000*/
1084:../SSC/Src/sdoserv.c ****             abort = ABORTIDX_UNSUPPORTED_ACCESS;
 2285              	 .loc 1 1084 0
 2286 01ec 0523     	 movs r3,#5
 2287 01ee FB73     	 strb r3,[r7,#15]
 2288 01f0 C9E0     	 b .L123
 2289              	.L122:
1085:../SSC/Src/sdoserv.c ****         }
1086:../SSC/Src/sdoserv.c ****         else
1087:../SSC/Src/sdoserv.c ****         {
1088:../SSC/Src/sdoserv.c ****             /* get the object handle of the requested index */
1089:../SSC/Src/sdoserv.c ****             pObjEntry = OBJ_GetObjectHandle( index );
 2290              	 .loc 1 1089 0
 2291 01f2 BB89     	 ldrh r3,[r7,#12]
 2292 01f4 1846     	 mov r0,r3
 2293 01f6 FFF7FEFF 	 bl OBJ_GetObjectHandle
 2294 01fa 7861     	 str r0,[r7,#20]
1090:../SSC/Src/sdoserv.c **** 
1091:../SSC/Src/sdoserv.c ****             if ( pObjEntry )
 2295              	 .loc 1 1091 0
 2296 01fc 7B69     	 ldr r3,[r7,#20]
 2297 01fe 002B     	 cmp r3,#0
 2298 0200 00F0BE80 	 beq .L124
 2299              	.LBB14:
1092:../SSC/Src/sdoserv.c ****             {
1093:../SSC/Src/sdoserv.c ****                 /* object exists */
1094:../SSC/Src/sdoserv.c ****                 UINT16 size = 0;
 2300              	 .loc 1 1094 0
 2301 0204 0023     	 movs r3,#0
 2302 0206 7B84     	 strh r3,[r7,#34]
1095:../SSC/Src/sdoserv.c ****                 if ( opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q )
 2303              	 .loc 1 1095 0
 2304 0208 97F82130 	 ldrb r3,[r7,#33]
 2305 020c 032B     	 cmp r3,#3
 2306 020e 2BD1     	 bne .L125
1096:../SSC/Src/sdoserv.c ****                 {
1097:../SSC/Src/sdoserv.c ****                     /* object description is requested */
1098:../SSC/Src/sdoserv.c ****                     OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Obj.Res, OBJ_GetObjDesc(pObjEntry),
 2307              	 .loc 1 1098 0
 2308 0210 7B68     	 ldr r3,[r7,#4]
 2309 0212 03F10E04 	 add r4,r3,#14
 2310 0216 7869     	 ldr r0,[r7,#20]
 2311 0218 FFF7FEFF 	 bl OBJ_GetObjDesc
 2312 021c 0346     	 mov r3,r0
 2313 021e 2046     	 mov r0,r4
 2314 0220 1946     	 mov r1,r3
 2315 0222 0422     	 movs r2,#4
 2316 0224 FFF7FEFF 	 bl memcpy
1099:../SSC/Src/sdoserv.c **** 
1100:../SSC/Src/sdoserv.c ****                     /* the mailbox should be big enough that the maximum object description
1101:../SSC/Src/sdoserv.c ****                     fits in the mailbox (the fragmentation is not done in the sample code),
1102:../SSC/Src/sdoserv.c ****                     so it will be checked only if the object description fits */
1103:../SSC/Src/sdoserv.c ****                     size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
 2317              	 .loc 1 1103 0
 2318 0228 BB89     	 ldrh r3,[r7,#12]
 2319 022a 1846     	 mov r0,r3
 2320 022c 0021     	 movs r1,#0
 2321 022e 7A69     	 ldr r2,[r7,#20]
 2322 0230 0023     	 movs r3,#0
 2323 0232 FFF7FEFF 	 bl OBJ_GetDesc
 2324 0236 0346     	 mov r3,r0
 2325 0238 0C33     	 adds r3,r3,#12
 2326 023a 7B84     	 strh r3,[r7,#34]
1104:../SSC/Src/sdoserv.c **** 
1105:../SSC/Src/sdoserv.c ****                     if ( size > (u16SendMbxSize - MBX_HEADER_SIZE) )
 2327              	 .loc 1 1105 0
 2328 023c 7A8C     	 ldrh r2,[r7,#34]
 2329 023e 364B     	 ldr r3,.L139+8
 2330 0240 1B88     	 ldrh r3,[r3]
 2331 0242 063B     	 subs r3,r3,#6
 2332 0244 9A42     	 cmp r2,r3
 2333 0246 02D9     	 bls .L126
1106:../SSC/Src/sdoserv.c ****                     {
1107:../SSC/Src/sdoserv.c ****                         /* size of the object description does not fit in the mailbox,
1108:../SSC/Src/sdoserv.c ****                         the object description will be sent without the name */
1109:../SSC/Src/sdoserv.c ****                         size = SIZEOF_SDOINFOOBJSTRUCT;
 2334              	 .loc 1 1109 0
 2335 0248 0C23     	 movs r3,#12
 2336 024a 7B84     	 strh r3,[r7,#34]
 2337 024c 7BE0     	 b .L128
 2338              	.L126:
1110:../SSC/Src/sdoserv.c ****                     }
1111:../SSC/Src/sdoserv.c ****                     else
1112:../SSC/Src/sdoserv.c ****                     {
1113:../SSC/Src/sdoserv.c ****                         /* object description fits in the mailbox, get the name of the object */
1114:../SSC/Src/sdoserv.c ****                         size = OBJ_GetDesc(index, 0, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->
 2339              	 .loc 1 1114 0
 2340 024e BA89     	 ldrh r2,[r7,#12]
 2341 0250 7B68     	 ldr r3,[r7,#4]
 2342 0252 0E33     	 adds r3,r3,#14
 2343 0254 0433     	 adds r3,r3,#4
 2344 0256 1046     	 mov r0,r2
 2345 0258 0021     	 movs r1,#0
 2346 025a 7A69     	 ldr r2,[r7,#20]
 2347 025c FFF7FEFF 	 bl OBJ_GetDesc
 2348 0260 0346     	 mov r3,r0
 2349 0262 0C33     	 adds r3,r3,#12
 2350 0264 7B84     	 strh r3,[r7,#34]
 2351 0266 6EE0     	 b .L128
 2352              	.L125:
 2353              	.LBB15:
1115:../SSC/Src/sdoserv.c ****                     }
1116:../SSC/Src/sdoserv.c ****                 }
1117:../SSC/Src/sdoserv.c ****                 else
1118:../SSC/Src/sdoserv.c ****                 {
1119:../SSC/Src/sdoserv.c ****                     /* entry description is requested,
1120:../SSC/Src/sdoserv.c ****                     get the requested subindex */
1121:../SSC/Src/sdoserv.c ****                     UINT8 subindex = (UINT8) ((pSdoInfoInd->SdoHeader.Data.Entry.Info & ENTRY_MASK_
 2354              	 .loc 1 1121 0
 2355 0268 7B68     	 ldr r3,[r7,#4]
 2356 026a DB89     	 ldrh r3,[r3,#14]
 2357 026c FB74     	 strb r3,[r7,#19]
1122:../SSC/Src/sdoserv.c **** 
1123:../SSC/Src/sdoserv.c ****                     /* get the maximum subindex */
1124:../SSC/Src/sdoserv.c ****                     UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEX
 2358              	 .loc 1 1124 0
 2359 026e 7869     	 ldr r0,[r7,#20]
 2360 0270 FFF7FEFF 	 bl OBJ_GetObjDesc
 2361 0274 0346     	 mov r3,r0
 2362 0276 5B88     	 ldrh r3,[r3,#2]
 2363 0278 BB74     	 strb r3,[r7,#18]
1125:../SSC/Src/sdoserv.c **** 
1126:../SSC/Src/sdoserv.c ****                     if ( subindex <= maxSubindex )
 2364              	 .loc 1 1126 0
 2365 027a FA7C     	 ldrb r2,[r7,#19]
 2366 027c BB7C     	 ldrb r3,[r7,#18]
 2367 027e 9A42     	 cmp r2,r3
 2368 0280 5FD8     	 bhi .L129
 2369              	.LBB16:
1127:../SSC/Src/sdoserv.c ****                     {
1128:../SSC/Src/sdoserv.c ****                         UINT16 ObjectFlags;
1129:../SSC/Src/sdoserv.c ****                         /* requested subindex is not too great */
1130:../SSC/Src/sdoserv.c ****                         /* get the entry description of the requested entry */
1131:../SSC/Src/sdoserv.c ****                         OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Entry.Res, OBJ_GetEntryDesc(pOb
 2370              	 .loc 1 1131 0
 2371 0282 7B68     	 ldr r3,[r7,#4]
 2372 0284 03F11004 	 add r4,r3,#16
 2373 0288 FB7C     	 ldrb r3,[r7,#19]
 2374 028a 7869     	 ldr r0,[r7,#20]
 2375 028c 1946     	 mov r1,r3
 2376 028e FFF7FEFF 	 bl OBJ_GetEntryDesc
 2377 0292 0346     	 mov r3,r0
 2378 0294 2046     	 mov r0,r4
 2379 0296 1946     	 mov r1,r3
 2380 0298 0622     	 movs r2,#6
 2381 029a FFF7FEFF 	 bl memcpy
1132:../SSC/Src/sdoserv.c **** 
1133:../SSC/Src/sdoserv.c ****                         /* the transmission of the value info is not supported yet of the sample co
1134:../SSC/Src/sdoserv.c ****                         pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
 2382              	 .loc 1 1134 0
 2383 029e 7B68     	 ldr r3,[r7,#4]
 2384 02a0 DB89     	 ldrh r3,[r3,#14]
 2385 02a2 DBB2     	 uxtb r3,r3
 2386 02a4 9AB2     	 uxth r2,r3
 2387 02a6 7B68     	 ldr r3,[r7,#4]
 2388 02a8 DA81     	 strh r2,[r3,#14]
1135:../SSC/Src/sdoserv.c ****                         ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
 2389              	 .loc 1 1135 0
 2390 02aa 7869     	 ldr r0,[r7,#20]
 2391 02ac FFF7FEFF 	 bl OBJ_GetObjDesc
 2392 02b0 0346     	 mov r3,r0
 2393 02b2 5B88     	 ldrh r3,[r3,#2]
 2394 02b4 3B82     	 strh r3,[r7,#16]
1136:../SSC/Src/sdoserv.c ****                         ObjectFlags = (ObjectFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT
 2395              	 .loc 1 1136 0
 2396 02b6 3B8A     	 ldrh r3,[r7,#16]
 2397 02b8 03F47063 	 and r3,r3,#3840
 2398 02bc 1B12     	 asrs r3,r3,#8
 2399 02be 3B82     	 strh r3,[r7,#16]
1137:../SSC/Src/sdoserv.c **** 
1138:../SSC/Src/sdoserv.c ****                         if(((ObjectFlags == OBJCODE_ARR) || (ObjectFlags == OBJCODE_REC)) && (subin
 2400              	 .loc 1 1138 0
 2401 02c0 3B8A     	 ldrh r3,[r7,#16]
 2402 02c2 082B     	 cmp r3,#8
 2403 02c4 02D0     	 beq .L130
 2404              	 .loc 1 1138 0 is_stmt 0 discriminator 2
 2405 02c6 3B8A     	 ldrh r3,[r7,#16]
 2406 02c8 092B     	 cmp r3,#9
 2407 02ca 0DD1     	 bne .L131
 2408              	.L130:
 2409              	 .loc 1 1138 0 discriminator 3
 2410 02cc FB7C     	 ldrb r3,[r7,#19]
 2411 02ce 002B     	 cmp r3,#0
 2412 02d0 0AD1     	 bne .L131
1139:../SSC/Src/sdoserv.c ****                         {
1140:../SSC/Src/sdoserv.c ****                             OBJTOMBXSTRCPY( ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry
 2413              	 .loc 1 1140 0 is_stmt 1
 2414 02d2 7B68     	 ldr r3,[r7,#4]
 2415 02d4 1033     	 adds r3,r3,#16
 2416 02d6 0633     	 adds r3,r3,#6
 2417 02d8 1846     	 mov r0,r3
 2418 02da 1149     	 ldr r1,.L139+16
 2419 02dc 0D22     	 movs r2,#13
 2420 02de FFF7FEFF 	 bl memcpy
1141:../SSC/Src/sdoserv.c ****                             size = 12 + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY); // 12: Length of "S
 2421              	 .loc 1 1141 0
 2422 02e2 1C23     	 movs r3,#28
 2423 02e4 7B84     	 strh r3,[r7,#34]
 2424 02e6 2BE0     	 b .L132
 2425              	.L131:
1142:../SSC/Src/sdoserv.c ****                         }
1143:../SSC/Src/sdoserv.c ****                         else
1144:../SSC/Src/sdoserv.c ****                         {
1145:../SSC/Src/sdoserv.c ****                             /* the mailbox should be big enough that the maximum entry description
1146:../SSC/Src/sdoserv.c ****                             fits in the mailbox (the fragmentation is not done in the sample code),
1147:../SSC/Src/sdoserv.c ****                             so it will be checked only if the entry description fits */
1148:../SSC/Src/sdoserv.c ****                             size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO +
 2426              	 .loc 1 1148 0
 2427 02e8 BA89     	 ldrh r2,[r7,#12]
 2428 02ea FB7C     	 ldrb r3,[r7,#19]
 2429 02ec 1046     	 mov r0,r2
 2430 02ee 1946     	 mov r1,r3
 2431 02f0 7A69     	 ldr r2,[r7,#20]
 2432 02f2 0023     	 movs r3,#0
 2433 02f4 FFF7FEFF 	 bl OBJ_GetDesc
 2434 02f8 0346     	 mov r3,r0
 2435 02fa 1033     	 adds r3,r3,#16
 2436 02fc 7B84     	 strh r3,[r7,#34]
1149:../SSC/Src/sdoserv.c ****                             if ( size > (u16SendMbxSize - MBX_HEADER_SIZE) )
 2437              	 .loc 1 1149 0
 2438 02fe 7A8C     	 ldrh r2,[r7,#34]
 2439 0300 054B     	 ldr r3,.L139+8
 2440 0302 1B88     	 ldrh r3,[r3]
 2441 0304 063B     	 subs r3,r3,#6
 2442 0306 9A42     	 cmp r2,r3
 2443 0308 0CD9     	 bls .L133
1150:../SSC/Src/sdoserv.c ****                             {
1151:../SSC/Src/sdoserv.c ****                                 /* size of the object description does not fit in the mailbox,
1152:../SSC/Src/sdoserv.c ****                                 the object description will be sent without the name */
1153:../SSC/Src/sdoserv.c ****                                 size =  SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
 2444              	 .loc 1 1153 0
 2445 030a 1023     	 movs r3,#16
 2446 030c 7B84     	 strh r3,[r7,#34]
 2447 030e 17E0     	 b .L132
 2448              	.L140:
 2449              	 .align 2
 2450              	.L139:
 2451 0310 00000000 	 .word aSdoInfoHeader
 2452 0314 00000000 	 .word nSdoInfoFragmentsLeft
 2453 0318 00000000 	 .word u16SendMbxSize
 2454 031c 00000000 	 .word nSdoInfoIndex
 2455 0320 00000000 	 .word aSubindexDesc
 2456              	.L133:
1154:../SSC/Src/sdoserv.c ****                             }
1155:../SSC/Src/sdoserv.c ****                             else
1156:../SSC/Src/sdoserv.c ****                             {
1157:../SSC/Src/sdoserv.c ****                                 /* object description fits in the mailbox, get the name of the entr
1158:../SSC/Src/sdoserv.c ****                                 size = OBJ_GetDesc(index, subindex, pObjEntry, ((UINT16 MBXMEM *) &
 2457              	 .loc 1 1158 0
 2458 0324 B989     	 ldrh r1,[r7,#12]
 2459 0326 7B68     	 ldr r3,[r7,#4]
 2460 0328 1033     	 adds r3,r3,#16
 2461 032a 0633     	 adds r3,r3,#6
 2462 032c FA7C     	 ldrb r2,[r7,#19]
 2463 032e 0846     	 mov r0,r1
 2464 0330 1146     	 mov r1,r2
 2465 0332 7A69     	 ldr r2,[r7,#20]
 2466 0334 FFF7FEFF 	 bl OBJ_GetDesc
 2467 0338 0346     	 mov r3,r0
 2468 033a 1033     	 adds r3,r3,#16
 2469 033c 7B84     	 strh r3,[r7,#34]
 2470              	.LBE16:
 2471 033e 02E0     	 b .L128
 2472              	.L132:
 2473 0340 01E0     	 b .L128
 2474              	.L129:
1159:../SSC/Src/sdoserv.c ****                             }
1160:../SSC/Src/sdoserv.c ****                         }
1161:../SSC/Src/sdoserv.c ****                     }
1162:../SSC/Src/sdoserv.c ****                     else
1163:../SSC/Src/sdoserv.c ****                         abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
 2475              	 .loc 1 1163 0
 2476 0342 1123     	 movs r3,#17
 2477 0344 FB73     	 strb r3,[r7,#15]
 2478              	.L128:
 2479              	.LBE15:
1164:../SSC/Src/sdoserv.c ****                 }
1165:../SSC/Src/sdoserv.c **** 
1166:../SSC/Src/sdoserv.c ****                 if ( abort == 0 )
 2480              	 .loc 1 1166 0
 2481 0346 FB7B     	 ldrb r3,[r7,#15]
 2482 0348 002B     	 cmp r3,#0
 2483 034a 18D1     	 bne .L134
1167:../SSC/Src/sdoserv.c ****                 {
1168:../SSC/Src/sdoserv.c ****                     {
1169:../SSC/Src/sdoserv.c ****                         /* for the object and entry description the sample code does not support th
1170:../SSC/Src/sdoserv.c ****                         the mailbox has to be big enough */
1171:../SSC/Src/sdoserv.c ****                         pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
 2484              	 .loc 1 1171 0
 2485 034c 7B68     	 ldr r3,[r7,#4]
 2486 034e 0022     	 movs r2,#0
 2487 0350 5A81     	 strh r2,[r3,#10]
1172:../SSC/Src/sdoserv.c ****                         /* store the size of the mailbox data in the mailbox buffer */
1173:../SSC/Src/sdoserv.c ****                         pSdoInfoInd->MbxHeader.Length = size;
 2488              	 .loc 1 1173 0
 2489 0352 7B68     	 ldr r3,[r7,#4]
 2490 0354 7A8C     	 ldrh r2,[r7,#34]
 2491 0356 1A80     	 strh r2,[r3]
1174:../SSC/Src/sdoserv.c ****                         /* set the opCode of the SDO Information response */
1175:../SSC/Src/sdoserv.c ****                         pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
 2492              	 .loc 1 1175 0
 2493 0358 7B68     	 ldr r3,[r7,#4]
 2494 035a 1B89     	 ldrh r3,[r3,#8]
 2495 035c 23F07F03 	 bic r3,r3,#127
 2496 0360 9AB2     	 uxth r2,r3
 2497 0362 7B68     	 ldr r3,[r7,#4]
 2498 0364 1A81     	 strh r2,[r3,#8]
1176:../SSC/Src/sdoserv.c ****                         pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE
 2499              	 .loc 1 1176 0
 2500 0366 7B68     	 ldr r3,[r7,#4]
 2501 0368 1A89     	 ldrh r2,[r3,#8]
 2502 036a 97F82130 	 ldrb r3,[r7,#33]
 2503 036e 9BB2     	 uxth r3,r3
 2504 0370 0133     	 adds r3,r3,#1
 2505 0372 9BB2     	 uxth r3,r3
 2506 0374 1343     	 orrs r3,r3,r2
 2507 0376 9AB2     	 uxth r2,r3
 2508 0378 7B68     	 ldr r3,[r7,#4]
 2509 037a 1A81     	 strh r2,[r3,#8]
 2510              	.LBE14:
 2511 037c 03E0     	 b .L123
 2512              	.L134:
 2513 037e 02E0     	 b .L123
 2514              	.L124:
1177:../SSC/Src/sdoserv.c ****                     }
1178:../SSC/Src/sdoserv.c ****                 }
1179:../SSC/Src/sdoserv.c ****             }
1180:../SSC/Src/sdoserv.c ****             else
1181:../SSC/Src/sdoserv.c ****                 abort = ABORTIDX_OBJECT_NOT_EXISTING;
 2515              	 .loc 1 1181 0
 2516 0380 0823     	 movs r3,#8
 2517 0382 FB73     	 strb r3,[r7,#15]
1182:../SSC/Src/sdoserv.c ****         }
1183:../SSC/Src/sdoserv.c ****         break;
 2518              	 .loc 1 1183 0
 2519 0384 02E0     	 b .L121
 2520              	.L123:
 2521              	 .loc 1 1183 0 is_stmt 0 discriminator 1
 2522 0386 01E0     	 b .L121
 2523              	.L138:
1184:../SSC/Src/sdoserv.c ****     default:
1185:../SSC/Src/sdoserv.c ****         abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 2524              	 .loc 1 1185 0 is_stmt 1
 2525 0388 0323     	 movs r3,#3
 2526 038a FB73     	 strb r3,[r7,#15]
 2527              	.L121:
1186:../SSC/Src/sdoserv.c ****     }
1187:../SSC/Src/sdoserv.c **** 
1188:../SSC/Src/sdoserv.c ****     if ( abort )
 2528              	 .loc 1 1188 0
 2529 038c FB7B     	 ldrb r3,[r7,#15]
 2530 038e 002B     	 cmp r3,#0
 2531 0390 1DD0     	 beq .L135
1189:../SSC/Src/sdoserv.c ****     {
1190:../SSC/Src/sdoserv.c ****         /* send a SDO Information Error response */
1191:../SSC/Src/sdoserv.c ****         pSdoInfoInd->MbxHeader.Length = SIZEOF_SDOINFOERRORSTRUCT;
 2532              	 .loc 1 1191 0
 2533 0392 7B68     	 ldr r3,[r7,#4]
 2534 0394 0A22     	 movs r2,#10
 2535 0396 1A80     	 strh r2,[r3]
1192:../SSC/Src/sdoserv.c **** 
1193:../SSC/Src/sdoserv.c ****         pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
 2536              	 .loc 1 1193 0
 2537 0398 7B68     	 ldr r3,[r7,#4]
 2538 039a 1B89     	 ldrh r3,[r3,#8]
 2539 039c 23F07F03 	 bic r3,r3,#127
 2540 03a0 9AB2     	 uxth r2,r3
 2541 03a2 7B68     	 ldr r3,[r7,#4]
 2542 03a4 1A81     	 strh r2,[r3,#8]
1194:../SSC/Src/sdoserv.c ****         pSdoInfoInd->SdoHeader.InfoHead |= (UINT16) ((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SH
 2543              	 .loc 1 1194 0
 2544 03a6 7B68     	 ldr r3,[r7,#4]
 2545 03a8 1B89     	 ldrh r3,[r3,#8]
 2546 03aa 43F00703 	 orr r3,r3,#7
 2547 03ae 9AB2     	 uxth r2,r3
 2548 03b0 7B68     	 ldr r3,[r7,#4]
 2549 03b2 1A81     	 strh r2,[r3,#8]
1195:../SSC/Src/sdoserv.c **** 
1196:../SSC/Src/sdoserv.c ****         pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
 2550              	 .loc 1 1196 0
 2551 03b4 7B68     	 ldr r3,[r7,#4]
 2552 03b6 0022     	 movs r2,#0
 2553 03b8 5A81     	 strh r2,[r3,#10]
1197:../SSC/Src/sdoserv.c ****         pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
 2554              	 .loc 1 1197 0
 2555 03ba FB7B     	 ldrb r3,[r7,#15]
 2556 03bc 1A46     	 mov r2,r3
 2557 03be 0C4B     	 ldr r3,.L141
 2558 03c0 53F82220 	 ldr r2,[r3,r2,lsl#2]
 2559 03c4 7B68     	 ldr r3,[r7,#4]
 2560 03c6 DA60     	 str r2,[r3,#12]
1198:../SSC/Src/sdoserv.c **** 
1199:../SSC/Src/sdoserv.c ****         nSdoInfoFragmentsLeft = 0;
 2561              	 .loc 1 1199 0
 2562 03c8 0A4B     	 ldr r3,.L141+4
 2563 03ca 0022     	 movs r2,#0
 2564 03cc 1A80     	 strh r2,[r3]
 2565              	.L135:
1200:../SSC/Src/sdoserv.c ****     }
1201:../SSC/Src/sdoserv.c **** 
1202:../SSC/Src/sdoserv.c ****     if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoInfoInd, flags) != 0)
 2566              	 .loc 1 1202 0
 2567 03ce 97F82F30 	 ldrb r3,[r7,#47]
 2568 03d2 7868     	 ldr r0,[r7,#4]
 2569 03d4 1946     	 mov r1,r3
 2570 03d6 FFF7FEFF 	 bl MBX_MailboxSendReq
 2571 03da 0346     	 mov r3,r0
 2572 03dc 002B     	 cmp r3,#0
 2573 03de 02D0     	 beq .L136
1203:../SSC/Src/sdoserv.c ****     {
1204:../SSC/Src/sdoserv.c ****         /* if the mailbox response could not be sent (or stored), the response will be
1205:../SSC/Src/sdoserv.c ****            stored in the variable pCoeSendStored and will be sent automatically
1206:../SSC/Src/sdoserv.c ****             from the mailbox handler (COE_ContinueInd) when the send mailbox will be read
1207:../SSC/Src/sdoserv.c ****             the next time from the master */
1208:../SSC/Src/sdoserv.c ****         pCoeSendStored = (TMBX MBXMEM *) pSdoInfoInd;
 2574              	 .loc 1 1208 0
 2575 03e0 054A     	 ldr r2,.L141+8
 2576 03e2 7B68     	 ldr r3,[r7,#4]
 2577 03e4 1360     	 str r3,[r2]
 2578              	.L136:
1209:../SSC/Src/sdoserv.c ****     }
1210:../SSC/Src/sdoserv.c **** 
1211:../SSC/Src/sdoserv.c ****     return 0;
 2579              	 .loc 1 1211 0
 2580 03e6 0023     	 movs r3,#0
 2581              	.L137:
1212:../SSC/Src/sdoserv.c **** }
 2582              	 .loc 1 1212 0 discriminator 2
 2583 03e8 1846     	 mov r0,r3
 2584 03ea 3437     	 adds r7,r7,#52
 2585              	.LCFI28:
 2586              	 .cfi_def_cfa_offset 12
 2587 03ec BD46     	 mov sp,r7
 2588              	.LCFI29:
 2589              	 .cfi_def_cfa_register 13
 2590              	 
 2591 03ee 90BD     	 pop {r4,r7,pc}
 2592              	.L142:
 2593              	 .align 2
 2594              	.L141:
 2595 03f0 00000000 	 .word cAbortCode
 2596 03f4 00000000 	 .word nSdoInfoFragmentsLeft
 2597 03f8 00000000 	 .word pCoeSendStored
 2598              	 .cfi_endproc
 2599              	.LFE177:
 2601              	 .text
 2602              	.Letext0:
 2603              	 .file 2 "c:\\davev4-64bit\\dave-4.3.2\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 2604              	 .file 3 "c:\\davev4-64bit\\dave-4.3.2\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 2605              	 .file 4 "../SSC/Src/mailbox.h"
 2606              	 .file 5 "../SSC/Src/ecatcoe.h"
 2607              	 .file 6 "../SSC/Src/sdoserv.h"
 2608              	 .file 7 "../SSC/Src/objdef.h"
 2609              	 .file 8 "C:/Workspaces/SOES-FW-UPDATE/ETHCAT_FWUPDATE_SSC_APPLICATION_XMC48/Libraries/CMSIS/Include/core_cm4.h"
DEFINED SYMBOLS
                            *ABS*:00000000 sdoserv.c
                            *COM*:00000001 u8PendingSdo
                            *COM*:00000001 bStoreCompleteAccess
                            *COM*:00000001 u8StoreSubindex
                            *COM*:00000002 u16StoreIndex
                            *COM*:00000004 u32StoreDataSize
                            *COM*:00000004 pStoreData
                            *COM*:00000004 pSdoPendFunc
                            *COM*:00000010 aSdoInfoHeader
                            *COM*:00000004 pSdoSegData
                            *COM*:00000002 nSdoInfoFragmentsLeft
    {standard input}:34     .rodata.cAbortCode:00000000 cAbortCode
    {standard input}:31     .rodata.cAbortCode:00000000 $d
                            *COM*:00000002 nSdoInfoIndex
                            *COM*:00000004 pSdoInfoObjEntry
                            *COM*:00000004 pSdoResStored
    {standard input}:72     .bss.bSdoInWork:00000000 bSdoInWork
    {standard input}:73     .bss.bSdoInWork:00000000 $d
                            *COM*:00000001 nSdoSegService
                            *COM*:00000001 bSdoSegFollows
                            *COM*:00000001 bSdoSegAccess
                            *COM*:00000002 nSdoSegIndex
                            *COM*:00000001 nSdoSegSubindex
                            *COM*:00000004 nSdoSegBytesToHandle
                            *COM*:00000001 bSdoSegLastToggle
                            *COM*:00000004 nSdoSegCompleteSize
                            *COM*:00000004 pSdoSegObjEntry
    {standard input}:84     .text.SdoDownloadSegmentInd:00000000 $t
    {standard input}:88     .text.SdoDownloadSegmentInd:00000000 SdoDownloadSegmentInd
    {standard input}:467    .text.SdoDownloadSegmentInd:00000234 $d
    {standard input}:491    .text.SdoUploadSegmentInd:00000000 $t
    {standard input}:495    .text.SdoUploadSegmentInd:00000000 SdoUploadSegmentInd
    {standard input}:715    .text.SdoUploadSegmentInd:0000014c $d
    {standard input}:726    .text.SdoRes:00000000 $t
    {standard input}:731    .text.SdoRes:00000000 SdoRes
    {standard input}:960    .text.SdoRes:00000160 $d
    {standard input}:966    .text.SDOS_SdoInd:00000000 $t
    {standard input}:971    .text.SDOS_SdoInd:00000000 SDOS_SdoInd
    {standard input}:1385   .text.SDOS_SdoInd:00000298 $d
    {standard input}:1399   .text.SDOS_SdoInd:000002c8 $t
    {standard input}:1772   .text.SDOS_SdoInd:00000530 $d
    {standard input}:1791   .text.SDOS_SdoRes:00000000 $t
    {standard input}:1796   .text.SDOS_SdoRes:00000000 SDOS_SdoRes
    {standard input}:1968   .text.SDOS_SdoRes:000000fc $d
    {standard input}:1982   .text.SDOS_SdoInfoInd:00000000 $t
    {standard input}:1987   .text.SDOS_SdoInfoInd:00000000 SDOS_SdoInfoInd
    {standard input}:2451   .text.SDOS_SdoInfoInd:00000310 $d
    {standard input}:2458   .text.SDOS_SdoInfoInd:00000324 $t
    {standard input}:2595   .text.SDOS_SdoInfoInd:000003f0 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memcpy
OBJ_Write
free
u16ReceiveMbxSize
u16SendMbxSize
MBX_MailboxSendReq
pCoeSendStored
OBJ_GetObjectHandle
OBJ_GetObjectLength
malloc
OBJ_Read
OBJ_GetNoOfObjects
OBJ_GetObjectList
OBJ_GetObjDesc
OBJ_GetDesc
OBJ_GetEntryDesc
aSubindexDesc
